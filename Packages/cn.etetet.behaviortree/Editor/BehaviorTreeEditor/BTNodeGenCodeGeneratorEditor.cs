using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace ET
{
    public static class BTNodeGenCodeGeneratorEditor
    {
        private const string NodeOutDirModel = "Packages/cn.etetet.btnode/Scripts/Model/Share/SourceGenerator";
        private const string NodeOutDirModelView = "Packages/cn.etetet.btnode/Scripts/ModelView/Share/SourceGenerator";
        private const string HandlerOutDirHotfixViewClient = "Packages/cn.etetet.btnode/Scripts/HotfixView/Client/SourceGenerator";
        private const string HandlerOutDirHotfixClient = "Packages/cn.etetet.btnode/Scripts/Hotfix/Client/SourceGenerator";
        private const string HandlerOutDirHotfixServer = "Packages/cn.etetet.btnode/Scripts/Hotfix/Server/SourceGenerator";
        private const string AutoGeneratedMarker = "// <auto-generated />";

        [MenuItem("ET/BehaviorTreeEditor/Generate BT Nodes")]
        public static void Generate()
        {
            try
            {
                int generatedNodes = 0;
                int generatedHandlers = 0;

                string projectRoot = GetProjectRoot();
                CleanOldGeneratedFiles(projectRoot);

                Dictionary<string, MethodInfo> nodeNameToMethod = new();
                foreach (MethodInfo method in EnumerateBTNodeGenMethods())
                {
                    ValidateMethodOrThrow(method);

                    string nodeName = GetNodeName(method.Name);
                    if (nodeNameToMethod.TryGetValue(nodeName, out MethodInfo existing))
                    {
                        throw new Exception($"BT节点名冲突: {nodeName}\n- {existing.DeclaringType?.FullName}.{existing.Name}\n- {method.DeclaringType?.FullName}.{method.Name}");
                    }
                    nodeNameToMethod[nodeName] = method;
                }

                foreach (MethodInfo method in nodeNameToMethod.Values)
                {
                    BTNodeGenAttribute attr = method.GetCustomAttribute<BTNodeGenAttribute>(false);
                    if (attr == null)
                    {
                        continue;
                    }

                    string nodeName = GetNodeName(method.Name);
                    string handlerName = $"{nodeName}Handler";

                    Type nodeBaseType = attr.NodeBaseType ?? throw new Exception($"方法未指定BT节点父类: {method.DeclaringType?.FullName}.{method.Name}");
                    if (!typeof(BTNode).IsAssignableFrom(nodeBaseType))
                    {
                        throw new Exception($"BTNodeGen父类不合法: {nodeBaseType.FullName} 不是 BTNode 子类: {method.DeclaringType?.FullName}.{method.Name}");
                    }
                    bool isCoroutineNode = typeof(BTCoroutine).IsAssignableFrom(nodeBaseType);

                    string nodeOutDir = Path.Combine(projectRoot, GetNodeOutDir(method));
                    Directory.CreateDirectory(nodeOutDir);
                    string nodePath = Path.Combine(nodeOutDir, $"{nodeName}.cs");
                    string nodeCode = GenerateNodeCode(nodeName, nodeBaseType, method);
                    if (WriteAllTextIfChanged(nodePath, nodeCode))
                    {
                        generatedNodes++;
                    }

                    string handlerDir = Path.Combine(projectRoot, GetHandlerOutDir(method));
                    Directory.CreateDirectory(handlerDir);
                    string handlerPath = Path.Combine(handlerDir, $"{handlerName}.cs");
                    string handlerCode = isCoroutineNode
                        ? GenerateCoroutineHandlerCode(nodeName, handlerName, method)
                        : GenerateHandlerCode(nodeName, handlerName, method);
                    if (WriteAllTextIfChanged(handlerPath, handlerCode))
                    {
                        generatedHandlers++;
                    }
                }

                AssetDatabase.Refresh();
                EditorUtility.DisplayDialog("BT生成完成", $"节点: {generatedNodes}\nHandler: {generatedHandlers}", "确定");
            }
            catch (Exception e)
            {
                Debug.LogError(e);
                EditorUtility.DisplayDialog("BT生成失败", e.Message, "确定");
            }
        }

        private static void CleanOldGeneratedFiles(string projectRoot)
        {
            List<string> dirs = new()
            {
                NodeOutDirModel,
                NodeOutDirModelView,
                HandlerOutDirHotfixViewClient,
                HandlerOutDirHotfixClient,
                HandlerOutDirHotfixServer,
            };

            foreach (string dir in dirs)
            {
                string fullDir = Path.Combine(projectRoot, dir);
                if (!Directory.Exists(fullDir))
                {
                    continue;
                }

                foreach (string file in Directory.EnumerateFiles(fullDir, "*.cs", SearchOption.TopDirectoryOnly))
                {
                    if (!IsAutoGeneratedFile(file))
                    {
                        continue;
                    }

                    File.Delete(file);
                    string meta = file + ".meta";
                    if (File.Exists(meta))
                    {
                        File.Delete(meta);
                    }
                }
            }
        }

        private static bool IsAutoGeneratedFile(string file)
        {
            try
            {
                using StreamReader reader = new(file, Encoding.UTF8, true);
                string firstLine = reader.ReadLine();
                return string.Equals(firstLine?.Trim(), AutoGeneratedMarker, StringComparison.Ordinal);
            }
            catch
            {
                return false;
            }
        }

        private static IEnumerable<MethodInfo> EnumerateBTNodeGenMethods()
        {
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                if (assembly.IsDynamic)
                {
                    continue;
                }

                Type[] types;
                try
                {
                    types = assembly.GetTypes();
                }
                catch (ReflectionTypeLoadException e)
                {
                    types = e.Types.Where(t => t != null).ToArray();
                }
                catch
                {
                    continue;
                }

                foreach (Type type in types)
                {
                    if (type == null)
                    {
                        continue;
                    }

                    foreach (MethodInfo method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))
                    {
                        if (method.GetCustomAttribute<BTNodeGenAttribute>(false) != null)
                        {
                            yield return method;
                        }
                    }
                }
            }
        }

        private static void ValidateMethodOrThrow(MethodInfo method)
        {
            if (!method.IsStatic)
            {
                throw new Exception($"BTNodeGen仅支持静态方法: {method.DeclaringType?.FullName}.{method.Name}");
            }

            foreach (ParameterInfo parameter in method.GetParameters())
            {
                if (parameter.ParameterType.IsByRef && !parameter.IsOut)
                {
                    throw new Exception($"BTNodeGen不支持ref/in参数: {method.DeclaringType?.FullName}.{method.Name} 参数 {parameter.Name}");
                }
            }

            BTNodeGenAttribute attr = method.GetCustomAttribute<BTNodeGenAttribute>(false);
            if (attr == null || attr.NodeBaseType == null)
            {
                throw new Exception($"必须指定BT节点父类: {method.DeclaringType?.FullName}.{method.Name} 需要 [BTNodeGen(typeof(BTAction))]");
            }

            bool isCoroutineNode = typeof(BTCoroutine).IsAssignableFrom(attr.NodeBaseType);
            if (isCoroutineNode)
            {
                if (method.ReturnType != typeof(ETTask))
                {
                    throw new Exception($"BTCoroutine节点方法返回值必须为ETTask: {method.DeclaringType?.FullName}.{method.Name}");
                }

                foreach (ParameterInfo parameter in method.GetParameters())
                {
                    if (parameter.IsOut)
                    {
                        throw new Exception($"BTCoroutine节点不允许out输出参数: {method.DeclaringType?.FullName}.{method.Name} 参数 {parameter.Name}");
                    }
                }
            }
            else
            {
                if (method.ReturnType != typeof(int))
                {
                    throw new Exception($"BTAction/BTCondition等节点方法返回值必须为int: {method.DeclaringType?.FullName}.{method.Name}");
                }
            }
        }

        private static string GenerateNodeCode(string nodeName, Type nodeBaseType, MethodInfo method)
        {
            StringBuilder sb = new();
            sb.AppendLine(AutoGeneratedMarker);
            sb.AppendLine("#nullable disable");
            sb.AppendLine("using Sirenix.OdinInspector;");
            sb.AppendLine();
            sb.AppendLine("namespace ET");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {nodeName}: {ToCSharpTypeName(nodeBaseType)}");
            sb.AppendLine("    {");

            foreach (ParameterInfo parameter in method.GetParameters())
            {
                string fieldName = ToPascal(parameter.Name);
                if (parameter.IsOut)
                {
                    Type outType = GetParameterElementType(parameter);
                    sb.AppendLine("        [BoxGroup(\"输出参数\")]");
                    sb.AppendLine($"        [BTOutput(typeof({ToCSharpTypeName(outType)}))]");
                    sb.AppendLine("        [LabelWidth(100)]");
                    sb.AppendLine($"        public string {fieldName} = \"{fieldName}\";");
                    sb.AppendLine();
                    continue;
                }

                if (HasBTInputMarker(parameter))
                {
                    Type inputType = GetParameterElementType(parameter);
                    sb.AppendLine("        [BoxGroup(\"输入参数\")]");
                    sb.AppendLine($"        [BTInput(typeof({ToCSharpTypeName(inputType)}))]");
                    sb.AppendLine("        [LabelWidth(100)]");
                    sb.AppendLine($"        public string {fieldName} = \"{fieldName}\";");
                    sb.AppendLine();
                    continue;
                }

                Type type = GetParameterElementType(parameter);
                sb.AppendLine("        [LabelWidth(100)]");
                sb.Append($"        public {ToCSharpTypeName(type)} {fieldName}");
                if (TryGetDefaultValueLiteral(parameter, out string defaultLiteral))
                {
                    sb.Append($" = {defaultLiteral}");
                }
                sb.AppendLine(";");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GenerateHandlerCode(string nodeName, string handlerName, MethodInfo method)
        {
            StringBuilder sb = new();
            sb.AppendLine(AutoGeneratedMarker);
            sb.AppendLine("#nullable disable");
            sb.AppendLine();

            string ns = method.DeclaringType?.Namespace ?? "ET";
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {handlerName}: ABTHandler<{nodeName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        protected override int Run({nodeName} node, BTEnv env)");
            sb.AppendLine("        {");

            List<string> callArgs = new();
            List<(Type Type, string KeyExpr, string ValueExpr)> outAdds = new();

            foreach (ParameterInfo parameter in method.GetParameters())
            {
                string fieldName = ToPascal(parameter.Name);
                string localName = parameter.Name;
                Type paramType = GetParameterElementType(parameter);

                if (parameter.IsOut)
                {
                    string outLocal = $"{localName}Out";
                    sb.AppendLine($"            {ToCSharpTypeName(paramType)} {outLocal} = default;");
                    callArgs.Add($"out {outLocal}");
                    outAdds.Add((paramType, $"node.{fieldName}", outLocal));
                    continue;
                }

                if (HasBTInputMarker(parameter))
                {
                    string getExpr = GetEnvGetExpression(paramType, $"node.{fieldName}");
                    sb.AppendLine($"            {ToCSharpTypeName(paramType)} {localName} = {getExpr};");
                    callArgs.Add(localName);
                    continue;
                }

                sb.AppendLine($"            {ToCSharpTypeName(paramType)} {localName} = node.{fieldName};");
                callArgs.Add(localName);
            }

            string declaringType = method.DeclaringType != null ? ToCSharpTypeName(method.DeclaringType) : throw new Exception("DeclaringType is null");
            sb.AppendLine($"            int ret = {declaringType}.{method.Name}({string.Join(", ", callArgs)});");
            foreach ((Type Type, string KeyExpr, string ValueExpr) outAdd in outAdds)
            {
                sb.AppendLine($"            {GetEnvAddExpression(outAdd.Type, outAdd.KeyExpr, outAdd.ValueExpr)};");
            }
            sb.AppendLine("            return ret;");

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GenerateCoroutineHandlerCode(string nodeName, string handlerName, MethodInfo method)
        {
            StringBuilder sb = new();
            sb.AppendLine(AutoGeneratedMarker);
            sb.AppendLine("#nullable disable");
            sb.AppendLine();

            string ns = method.DeclaringType?.Namespace ?? "ET";
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {handlerName}: ABTCoroutineHandler<{nodeName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        protected override async ETTask RunAsync({nodeName} node, BTEnv env)");
            sb.AppendLine("        {");
            sb.AppendLine("            Buff buff = env.GetEntity<Buff>(node.Buff);");

            List<string> callArgs = new();
            foreach (ParameterInfo parameter in method.GetParameters())
            {
                Type paramType = GetParameterElementType(parameter);

                if (paramType == typeof(Buff))
                {
                    callArgs.Add("buff");
                    continue;
                }

                if (paramType == typeof(BTEnv))
                {
                    callArgs.Add("env");
                    continue;
                }

                string fieldName = ToPascal(parameter.Name);
                string localName = parameter.Name;

                if (HasBTInputMarker(parameter))
                {
                    string getExpr = GetEnvGetExpression(paramType, $"node.{fieldName}");
                    sb.AppendLine($"            {ToCSharpTypeName(paramType)} {localName} = {getExpr};");
                    callArgs.Add(localName);
                    continue;
                }

                sb.AppendLine($"            {ToCSharpTypeName(paramType)} {localName} = node.{fieldName};");
                callArgs.Add(localName);
            }

            string declaringType = method.DeclaringType != null ? ToCSharpTypeName(method.DeclaringType) : throw new Exception("DeclaringType is null");
            sb.AppendLine($"            await {declaringType}.{method.Name}({string.Join(", ", callArgs)});");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GetHandlerOutDir(MethodInfo method)
        {
            string ns = method.DeclaringType?.Namespace ?? string.Empty;

            // HotfixView目前只支持Client目录
            if (IsHotfixViewMethod(method))
            {
                if (ns.Contains(".Server", StringComparison.Ordinal))
                {
                    throw new Exception($"HotfixView方法不应放在Server命名空间: {method.DeclaringType?.FullName}.{method.Name}");
                }
                return HandlerOutDirHotfixViewClient;
            }

            bool isServer = ns.Contains(".Server", StringComparison.Ordinal);
            if (isServer)
            {
                return HandlerOutDirHotfixServer;
            }

            return HandlerOutDirHotfixClient;
        }

        private static string GetNodeOutDir(MethodInfo method)
        {
            return IsHotfixViewMethod(method) ? NodeOutDirModelView : NodeOutDirModel;
        }

        private static bool IsHotfixViewMethod(MethodInfo method)
        {
            string asmName = method.DeclaringType?.Assembly?.GetName().Name ?? string.Empty;
            if (asmName.IndexOf("HotfixView", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return true;
            }

            // 兜底：某些情况下Editor里AssemblyName可能不稳定
            string ns = method.DeclaringType?.Namespace ?? string.Empty;
            return ns.Contains("ET.Client", StringComparison.Ordinal) && UsesUnityEngine(method);
        }

        private static bool UsesUnityEngine(MethodInfo method)
        {
            if (TypeUsesUnityEngine(method.DeclaringType))
            {
                return true;
            }

            foreach (ParameterInfo p in method.GetParameters())
            {
                if (TypeUsesUnityEngine(GetParameterElementType(p)))
                {
                    return true;
                }
            }

            return false;
        }

        private static bool TypeUsesUnityEngine(Type t)
        {
            if (t == null)
            {
                return false;
            }

            if (t.IsByRef)
            {
                t = t.GetElementType();
            }

            string ns = t.Namespace ?? string.Empty;
            return ns.StartsWith("UnityEngine", StringComparison.Ordinal);
        }

        private static bool HasBTInputMarker(ParameterInfo parameter)
        {
            return parameter.GetCustomAttributes(typeof(BTInput), false).Length > 0;
        }

        private static Type GetParameterElementType(ParameterInfo parameter)
        {
            Type t = parameter.ParameterType;
            return t.IsByRef ? t.GetElementType() : t;
        }

        private static string GetEnvGetExpression(Type type, string keyExpr)
        {
            if (IsEntityLike(type))
            {
                return $"env.GetEntity<{ToCSharpTypeName(type)}>({keyExpr})";
            }

            if (type.IsValueType)
            {
                return $"env.GetStruct<{ToCSharpTypeName(type)}>({keyExpr})";
            }

            return $"env.GetObject<{ToCSharpTypeName(type)}>({keyExpr})";
        }

        private static string GetEnvAddExpression(Type type, string keyExpr, string valueExpr)
        {
            if (IsEntityLike(type))
            {
                return $"env.AddEntity<{ToCSharpTypeName(type)}>({keyExpr}, {valueExpr})";
            }

            if (type.IsValueType)
            {
                return $"env.AddStruct<{ToCSharpTypeName(type)}>({keyExpr}, {valueExpr})";
            }

            return $"env.AddObject<{ToCSharpTypeName(type)}>({keyExpr}, {valueExpr})";
        }

        private static bool IsEntityLike(Type type)
        {
            if (type == null)
            {
                return false;
            }

            if (type.IsByRef)
            {
                type = type.GetElementType();
            }

            if (typeof(Entity).IsAssignableFrom(type))
            {
                return true;
            }

            // ET.LSEntity 可能不在Editor程序集引用中，这里用FullName做弱判断
            for (Type t = type; t != null; t = t.BaseType)
            {
                if (t.FullName == "ET.LSEntity")
                {
                    return true;
                }
            }

            return false;
        }

        private static string GetNodeName(string methodName)
        {
            return methodName.StartsWith("BT", StringComparison.Ordinal) ? methodName : $"BT{methodName}";
        }

        private static string ToPascal(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return name;
            }
            if (name.Length == 1)
            {
                return name.ToUpperInvariant();
            }
            return char.ToUpperInvariant(name[0]) + name.Substring(1);
        }

        private static bool TryGetDefaultValueLiteral(ParameterInfo parameter, out string literal)
        {
            literal = null;
            if (!parameter.HasDefaultValue)
            {
                return false;
            }

            object value = parameter.DefaultValue;
            if (value == null)
            {
                literal = "null";
                return true;
            }

            switch (value)
            {
                case bool b:
                    literal = b ? "true" : "false";
                    return true;
                case string s:
                    literal = "@\"" + s.Replace("\"", "\"\"") + "\"";
                    return true;
                case char c:
                    literal = "'" + (c == '\'' ? "\\'" : c.ToString()) + "'";
                    return true;
                case float f:
                    literal = f.ToString("R", CultureInfo.InvariantCulture) + "f";
                    return true;
                case double d:
                    literal = d.ToString("R", CultureInfo.InvariantCulture) + "d";
                    return true;
                case decimal m:
                    literal = m.ToString(CultureInfo.InvariantCulture) + "m";
                    return true;
            }

            if (value.GetType().IsEnum)
            {
                literal = ToCSharpTypeName(value.GetType()) + "." + value.ToString();
                return true;
            }

            if (value is sbyte or byte or short or ushort or int or uint or long or ulong)
            {
                literal = Convert.ToString(value, CultureInfo.InvariantCulture);
                return true;
            }

            return false;
        }

        private static bool WriteAllTextIfChanged(string path, string content)
        {
            if (File.Exists(path))
            {
                string existing = File.ReadAllText(path);
                if (string.Equals(existing, content, StringComparison.Ordinal))
                {
                    return false;
                }
            }

            File.WriteAllText(path, content, new UTF8Encoding(false));
            return true;
        }

        private static string GetProjectRoot()
        {
            string assetsPath = Application.dataPath;
            return Path.GetFullPath(Path.Combine(assetsPath, ".."));
        }

        private static string ToCSharpTypeName(Type type)
        {
            if (type == typeof(void)) return "void";
            if (type == typeof(bool)) return "bool";
            if (type == typeof(byte)) return "byte";
            if (type == typeof(sbyte)) return "sbyte";
            if (type == typeof(short)) return "short";
            if (type == typeof(ushort)) return "ushort";
            if (type == typeof(int)) return "int";
            if (type == typeof(uint)) return "uint";
            if (type == typeof(long)) return "long";
            if (type == typeof(ulong)) return "ulong";
            if (type == typeof(float)) return "float";
            if (type == typeof(double)) return "double";
            if (type == typeof(decimal)) return "decimal";
            if (type == typeof(string)) return "string";
            if (type == typeof(object)) return "object";

            if (type.IsByRef)
            {
                type = type.GetElementType();
            }

            if (type.IsArray)
            {
                return $"{ToCSharpTypeName(type.GetElementType())}[]";
            }

            if (type.IsGenericType)
            {
                string genericTypeName = type.GetGenericTypeDefinition().FullName;
                genericTypeName = genericTypeName.Substring(0, genericTypeName.IndexOf('`'));
                Type[] args = type.GetGenericArguments();
                return $"global::{genericTypeName}<{string.Join(", ", args.Select(ToCSharpTypeName))}>";
            }

            if (type.IsNested && type.DeclaringType != null)
            {
                return $"{ToCSharpTypeName(type.DeclaringType)}.{type.Name}";
            }

            return $"global::{type.FullName}";
        }
    }
}
