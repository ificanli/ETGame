# 9.1 碰撞实现说明

## 一句话结论
本项目主线（`cn.etetet.map + cn.etetet.move + cn.etetet.recast`）的碰撞方案是：

- 用 `Recast NavMesh` 约束可行走区域（决定“能不能走过去”）
- 用 `MoveComponent` 按路径点做逻辑插值移动（决定“怎么走过去”）
- 用少量 `Physics.Raycast` 做点击与贴地（决定“点中了谁/地面高度”）

不是基于 `Rigidbody + OnCollision/OnTrigger` 的动力学碰撞驱动。

---

## 先区分三类“碰撞”

### 1. 可达性碰撞（路被挡住）
由导航网格决定。不可走区域不会进入路径点，角色不会走进去。

### 2. 交互碰撞（鼠标点选）
由 Unity 射线检测决定。比如点击单位、贴地取高度。

### 3. 动力学碰撞（刚体推挤/反弹）
当前主线没有采用这套作为角色移动核心。

---

## 运行时链路（按时序）

### 1. 客户端输入移动意图
玩家输入后调用：

- `Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs:82`

对应代码：`unit.MoveToAsync(targetPos).Coroutine();`

### 2. 客户端把目标点发给服务端
发送 `C2M_PathfindingResult`：

- `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/MoveHelper.cs:10`

### 3. 服务端收到后执行寻路
入口：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/C2M_PathfindingResultHandler.cs:11`

调用：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/MoveHelper.cs:19`

核心是 `PathfindingComponent.Find(start, target, points)`。

### 4. Recast/Detour 计算路径
寻路细节在：

- `Packages/cn.etetet.recast/Scripts/Hotfix/Share/PathfindingComponentSystem.cs:52`
- `Packages/cn.etetet.recast/Scripts/Hotfix/Share/PathfindingComponentSystem.cs:55`
- `Packages/cn.etetet.recast/Scripts/Hotfix/Share/PathfindingComponentSystem.cs:73`

流程是：

1. 找起点和终点最近可行走多边形（`FindNearestPoly`）
2. 计算多边形路径（`FindPath`）
3. 拉直为路径点（`FindStraightPath`）

### 5. 服务端广播路径并驱动移动
服务端拿到路径后广播 `M2C_PathfindingResult`，再调用 `MoveComponent.MoveToAsync`：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/MoveHelper.cs:35`

### 6. 客户端按同一路径插值表现
客户端收到路径：

- `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/M2C_PathfindingResultHandler.cs:12`

移动实现本体：

- `Packages/cn.etetet.move/Scripts/Hotfix/Share/MoveComponentSystem.cs:111`
- `Packages/cn.etetet.move/Scripts/Hotfix/Share/MoveComponentSystem.cs:140`

这里是 `math.lerp` 插值，不是物理引擎推进行为。

---

## 导航数据从哪里来

### 1. 导航网格加载
`NavmeshComponent.Load(name)` 会读取二进制导航数据：

- `Packages/cn.etetet.recast/Scripts/Model/Share/NavmeshComponent.cs:23`
- `Packages/cn.etetet.recast/Scripts/Model/Share/NavmeshComponent.cs:42`

### 2. Recast 文件来源
读取路径：

- `Packages/cn.etetet.map/CodeMode/Hotfix/Server/RecastFileLoader.cs:12`
- `Packages/cn.etetet.map/CodeMode/HotfixView/Client/RecastFileLoader.cs:12`

文件目录：

- `Packages/cn.etetet.map/Bundles/Recast/Map1.bytes`
- `Packages/cn.etetet.map/Bundles/Recast/Map2.bytes`
- `Packages/cn.etetet.map/Bundles/Recast/Lordaeron.bytes`

### 3. 何时加载

- 服务端地图启动时加载：`Packages/cn.etetet.map/Scripts/Hotfix/Server/FiberInit_Map.cs:32`
- 客户端切场景时加载：`Packages/cn.etetet.map/Scripts/Hotfix/Client/SceneChangeHelper.cs:26`

---

## Unity Physics 在这里做了什么

当前主要用于射线检测，不是角色动力学移动：

- 点选单位：`Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs:92`
- 贴地修正：`Packages/cn.etetet.map/Scripts/HotfixView/Client/Unit/GameObjectPosHelper.cs:12`

另外，场景/预制体里存在 `Collider`，主要用于被射线命中与场景几何描述。

---

## 为什么你会感觉“像碰撞”

因为最终效果是“角色不会穿越不可达区域”，这来自导航网格约束，而不是刚体碰撞响应。

也就是说：

- “走不过去”是寻路层面拒绝
- 不是移动到墙边后由 `OnCollision` 把角色弹开

---

## 当前方案的优缺点

### 优点

- 服务器可控、可复现，适合 MMO
- 带宽和同步开销可控
- 逻辑与表现解耦（路径和插值分层）

### 限制

- 默认没有刚体推挤、反弹等动力学交互
- 角色间实时物理互相挤压不是主流程

---

## 排查建议

### 1. 点击单位无反应
先看是否命中 `Unit` Layer（`InputSystemComponentSystem.cs:92`）。

### 2. 点地后不移动
看服务端是否拿到有效路径点（`MoveHelper.cs:19` 后 `Points.Count`）。

### 3. 切图后寻路异常
看 Recast 数据是否存在且加载成功（`Bundles/Recast/*.bytes` 与 `NavmeshComponent.Load`）。

---

## 总结
你这个项目的“碰撞处理”核心是 **导航碰撞（NavMesh）+ 逻辑移动**，而不是 **Unity 刚体碰撞**。  
如果后续要做“推箱子/击退反弹/刚体阻挡”，需要额外设计物理层并和现有路径层做规则整合。

