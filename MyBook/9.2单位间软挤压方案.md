# 9.2 单位间软挤压方案

## 目标
在不引入 `Rigidbody` 动力学的前提下，为当前 `NavMesh + 逻辑移动` 体系增加“单位靠近时轻微分离”的效果，避免明显重叠。

---

## 设计原则

1. 服务器权威  
最终位置只由服务端计算，客户端只做表现或预测。

2. 不破坏现有主链路  
保持现有 `寻路 -> 路径点 -> MoveComponent 插值` 主流程不变，只在移动后追加“微调位移”。

3. 可配置、无硬编码  
半径、强度、每帧最大修正量等全部走配置（Luban/数值），不同单位类型可独立调参。

4. 低复杂度  
使用 AOI 邻居做候选，避免全图两两检测。

---

## 架构落点（建议）

### 包与职责

- `cn.etetet.map`：放“单位软挤压规则”与事件入口
- `cn.etetet.move`：保持移动插值职责，不直接耦合业务规则
- `cn.etetet.aoi`：提供邻近单位集合（候选集）

### ECS 拆分

- `SoftPushComponent`（挂在 Unit）  
只存参数与运行态数据。

- `SoftPushSystem`  
计算分离向量并修正位置。

- 触发方式  
在服务端单位移动 tick 后调用（每帧/每固定间隔），只处理“正在移动”单位。

---

## 核心数据（建议字段）

`SoftPushComponent`（示例）：

- `Radius`：挤压半径
- `Strength`：挤压强度系数
- `MaxOffsetPerTick`：单次最大修正距离
- `DeadZone`：死区，避免抖动
- `Mass`：质量权重（大单位更不容易被推）
- `EnableSoftPush`：开关
- `LastPushTime`：节流时间戳（可选）

以上字段建议来自配置表，不写死在代码里。

---

## 计算流程

### 1. 获取候选邻居
从 AOI（同格 + 邻格，或可见单位）拿候选单位，过滤：

- 自己
- 非同场景/非同相位
- 已销毁或不可交互单位
- 未启用软挤压单位

### 2. 计算重叠
对每个邻居：

- `dir = selfPos - otherPos`
- `dist = length(dir)`
- `minDist = self.Radius + other.Radius`
- 若 `dist >= minDist` 则不处理

重叠量：

- `penetration = minDist - dist`

方向：

- 当 `dist` 很小（几乎重合）时，使用稳定后备方向（上帧方向或固定哈希方向）
- 否则 `n = normalize(dir)`

### 3. 质量分配与累计
按质量分摊：

- `selfShare = other.Mass / (self.Mass + other.Mass)`

累计位移：

- `offset += n * penetration * selfShare * Strength`

### 4. 限幅与死区

- 若 `length(offset) < DeadZone` 则置 0
- 若超过 `MaxOffsetPerTick` 则归一化后截断

### 5. 导航网格回贴
修正后的目标点做一次 NavMesh 最近点回贴，避免被推出可行走区：

- `newPos = RecastFindNearestPoint(selfPos + offset)`

### 6. 写回位置并走现有同步
写 `unit.Position = newPos`，沿用现有位置广播与 AOI 事件链。

---

## 伪代码

```csharp
if (!self.SoftPush.EnableSoftPush) return;
if (!self.IsMoving()) return;

float3 offset = float3.zero;
foreach (Unit other in GetNeighborsFromAOI(self))
{
    if (!CanSoftPush(self, other)) continue;

    float3 dir = self.Position - other.Position;
    float dist = math.length(dir);
    float minDist = self.SoftPush.Radius + other.SoftPush.Radius;
    if (dist >= minDist) continue;

    float3 n = dist > epsilon ? dir / dist : GetStableFallbackDir(self, other);
    float penetration = minDist - dist;
    float share = other.SoftPush.Mass / (self.SoftPush.Mass + other.SoftPush.Mass);
    offset += n * penetration * share * self.SoftPush.Strength;
}

offset = ApplyDeadZoneAndClamp(offset, self.SoftPush.DeadZone, self.SoftPush.MaxOffsetPerTick);
if (math.lengthsq(offset) > 0)
{
    float3 target = self.Position + offset;
    self.Position = self.GetComponent<PathfindingComponent>().RecastFindNearestPoint(target);
}
```

---

## 与现有系统对接点

建议接在“服务端移动更新之后”：

- 现有移动插值：`Packages/cn.etetet.move/Scripts/Hotfix/Share/MoveComponentSystem.cs`
- 现有寻路入口：`Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/MoveHelper.cs`
- AOI 相关：`Packages/cn.etetet.aoi/Scripts/Hotfix/Server`

推荐顺序：

1. `MoveComponent` 先更新到本帧目标位
2. `SoftPushSystem` 做微小分离
3. 触发已有位置变化流程（AOI/广播）

---

## 关键参数建议（由配置提供）

- `Radius`：与模型碰撞体视觉尺寸一致或略小
- `Strength`：建议从小到大调，避免弹跳感
- `MaxOffsetPerTick`：小值，保证“软”而非硬推
- `DeadZone`：消抖，防止小幅来回抖动
- `Mass`：可按单位体型/类型分层

---

## 冲突策略建议

### 1. 玩家优先
玩家与怪物重叠时，怪物让步更多（提高怪物 `selfShare`）。

### 2. Boss 稳定
Boss 可设置大质量，减少被推开。

### 3. 非战斗单位
可关闭软挤压，减少无意义计算。

---

## 性能策略

1. 仅处理移动中的单位  
静止单位不做主动计算。

2. AOI 限制邻居数量  
可配置 `MaxNeighbors`，超限按距离最近优先。

3. 固定时间步  
按固定频率做软挤压，不必每帧都做。

---

## 同步与体验

1. 服务端权威  
客户端收到位置同步后纠正漂移。

2. 客户端可选轻预测  
本地可用同算法做视觉预测，但必须接受服务端回正。

3. 防抖动  
死区 + 限幅 + 质量分配是关键。

---

## 测试清单

1. `1v1` 对撞：是否平滑分离
2. `N` 人聚堆：是否稳定、无抖动
3. 墙边挤压：是否被回贴到可走区
4. 玩家与 Boss：是否符合质量优先级
5. 高延迟：是否出现明显来回弹
6. 大场景：CPU 是否可控

---

## 分阶段落地建议

1. 第一阶段  
只做“移动单位 vs 邻居”的单边修正（实现最快，风险低）。

2. 第二阶段  
加入质量体系、职业/单位类型权重。

3. 第三阶段  
按战斗状态切换参数（战斗中更强，非战斗更弱）。

---

## 结论
该方案能在不改动现有主架构的前提下，解决“单位重叠明显”的问题，且与当前 ET 的服务端权威、ECS、NavMesh 路线一致。  
核心做法是：**移动后做小幅分离修正 + NavMesh 回贴 + 参数化调优**。

