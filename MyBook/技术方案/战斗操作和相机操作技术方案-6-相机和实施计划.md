# 战斗操作和相机操作技术方案 - 第6部分：相机系统和实施计划

## 19. 相机系统设计

### 19.1 基于现有Cinemachine的固定俯视相机

根据现有代码，项目已经使用Cinemachine。我们需要配置固定俯视相机。

### 19.2 CinemachineComponent扩展

```csharp
[ComponentOf(typeof(Unit))]
public class CinemachineComponent: Entity, IAwake, IDestroy
{
    public CinemachineFreeLook FreeLook;
    public CinemachineVirtualCamera VirtualCamera;
    public Transform Follow;
    public Transform Head;

    // 新增：固定俯视相机配置
    public bool IsFixedTopDown = true;      // 是否固定俯视
    public float FixedPitch = 60f;          // 固定俯仰角（度）
    public float FixedDistance = 10f;       // 固定距离（米）
    public float FixedHeight = 8f;          // 固定高度（米）
}
```

### 19.3 固定俯视相机设置

```csharp
[EntitySystemOf(typeof(CinemachineComponent))]
public static partial class CinemachineComponentSystem
{
    [EntitySystem]
    private static void Awake(this CinemachineComponent self)
    {
        // 读取配置
        CameraConfig config = CameraConfigCategory.Instance.Get(1);
        if (config != null)
        {
            self.IsFixedTopDown = config.IsFixedTopDown;
            self.FixedPitch = config.FixedPitch;
            self.FixedDistance = config.FixedDistance;
            self.FixedHeight = config.FixedHeight;
        }
    }

    // 设置固定俯视相机
    public static void SetupFixedTopDownCamera(this CinemachineComponent self, Unit unit)
    {
        if (!self.IsFixedTopDown)
            return;

        // 获取或创建虚拟相机
        if (self.VirtualCamera == null)
        {
            GameObject vcamObj = new GameObject("FixedTopDownCamera");
            self.VirtualCamera = vcamObj.AddComponent<CinemachineVirtualCamera>();
        }

        // 设置跟随目标
        self.Follow = unit.GetComponent<GameObjectComponent>().GameObject.transform;
        self.VirtualCamera.Follow = self.Follow;
        self.VirtualCamera.LookAt = self.Follow;

        // 配置Transposer（位置控制）
        CinemachineTransposer transposer = self.VirtualCamera.GetCinemachineComponent<CinemachineTransposer>();
        if (transposer == null)
        {
            transposer = self.VirtualCamera.AddCinemachineComponent<CinemachineTransposer>();
        }

        // 设置固定偏移（俯视角）
        float pitchRad = self.FixedPitch * Mathf.Deg2Rad;
        float offsetZ = -self.FixedDistance * Mathf.Cos(pitchRad);
        float offsetY = self.FixedHeight;

        transposer.m_FollowOffset = new Vector3(0, offsetY, offsetZ);
        transposer.m_BindingMode = CinemachineTransposer.BindingMode.WorldSpace;
        transposer.m_XDamping = 0.5f;  // 平滑跟随
        transposer.m_YDamping = 0.5f;
        transposer.m_ZDamping = 0.5f;

        // 配置Composer（朝向控制）
        CinemachineComposer composer = self.VirtualCamera.GetCinemachineComponent<CinemachineComposer>();
        if (composer == null)
        {
            composer = self.VirtualCamera.AddCinemachineComponent<CinemachineComposer>();
        }

        // 固定俯视角度
        composer.m_TrackedObjectOffset = Vector3.zero;
        composer.m_LookaheadTime = 0;
        composer.m_LookaheadSmoothing = 0;
        composer.m_HorizontalDamping = 0.5f;
        composer.m_VerticalDamping = 0.5f;

        // 禁用输入控制（固定相机，不允许旋转/缩放）
        self.VirtualCamera.GetComponent<CinemachineInputProvider>()?.enabled = false;
    }

    // 移除旧的RotationFollow方法（不再需要手动旋转控制）
}
```

### 19.4 相机配置表

```csharp
// CameraConfig.xlsx
public class CameraConfig
{
    public int Id;
    public bool IsFixedTopDown = true;      // 是否固定俯视
    public float FixedPitch = 60f;          // 固定俯仰角（度，0-90）
    public float FixedDistance = 10f;       // 固定距离（米）
    public float FixedHeight = 8f;          // 固定高度（米）
    public float FollowDamping = 0.5f;      // 跟随平滑度（0-1）
    public float LookDamping = 0.5f;        // 朝向平滑度（0-1）
}
```

### 19.5 客户端相机初始化

```csharp
// 在创建玩家Unit时初始化相机
public static void OnCreateMyUnit(Scene scene, Unit unit)
{
    // 添加相机组件
    CinemachineComponent cameraComp = unit.AddComponent<CinemachineComponent>();

    // 设置固定俯视相机
    cameraComp.SetupFixedTopDownCamera(unit);
}
```

---

## 20. 实施计划

### 20.1 阶段划分

#### 阶段1：移动系统（3-4天）

**目标**：实现摇杆移动的基础功能

**任务**：
1. 扩展MoveComponent，添加Joystick模式字段
2. 实现网络协议（C2M_JoystickInput、M2C_JoystickState）
3. 实现客户端输入采集和发送
4. 实现服务端输入处理和Tick移动
5. 实现客户端预测和服务端回正
6. 实现NavMesh条件回贴
7. 实现Seq溢出处理
8. 单元测试和压力测试

**验收标准**：
- 摇杆移动流畅，无明显延迟
- 客户端预测误差小于0.5米
- 12人同屏移动，服务端CPU占用<20%
- 网络丢包50%情况下仍可正常移动

#### 阶段2：阵营和目标选择（2-3天）

**目标**：实现阵营系统和自动目标选择

**任务**：
1. 实现CampComponent和阵营关系判断
2. 实现TargetSelectorComponent
3. 实现目标选择算法（距离、血量、攻击优先级）
4. 实现手动切换目标协议和逻辑
5. 配置表设计和数据填充
6. 功能测试

**验收标准**：
- 正确识别敌我关系
- 自动选择最优目标
- 手动切换目标响应及时
- 目标选择性能开销<1ms

#### 阶段3：武器系统（2-3天）

**目标**：实现双武器系统和子弹系统

**任务**：
1. 实现WeaponComponent
2. 实现弹药管理（消耗、补充）
3. 实现子弹系统（BulletComponent）
4. 实现伤害计算和应用
5. 配置表设计（WeaponConfig）
6. 功能测试

**验收标准**：
- 步枪和冲锋枪独立工作
- 弹药正确消耗和补充
- 子弹命中判定准确
- 伤害计算正确

#### 阶段4：行为树系统（4-5天）

**目标**：实现BT框架和武器BT

**任务**：
1. 实现BT基础框架（BTNode、BTContext、BTComponent）
2. 实现组合节点（Sequence、Selector、Parallel）
3. 实现条件节点（CheckHasTarget、CheckInRange、CheckNotMoving等）
4. 实现行动节点（AimAtTarget、SpawnBullet、ConsumeAmmo等）
5. 构建步枪BT（静止射击）
6. 构建冲锋枪BT（移动射击）
7. 构建换弹BT
8. BT与Buff系统集成
9. 功能测试和调优

**验收标准**：
- 步枪只能静止射击
- 冲锋枪可以移动射击
- 换弹逻辑正确
- BT性能开销<2ms/Unit

#### 阶段5：相机系统（1-2天）

**目标**：实现固定俯视相机

**任务**：
1. 扩展CinemachineComponent
2. 配置固定俯视相机参数
3. 实现平滑跟随
4. 配置表设计
5. 功能测试

**验收标准**：
- 相机固定俯视角度
- 平滑跟随玩家
- 无旋转/缩放操作
- 视野范围合适

#### 阶段6：集成测试和优化（3-4天）

**目标**：整体集成和性能优化

**任务**：
1. 完整功能集成测试
2. 12人同屏压力测试
3. 网络延迟和丢包测试
4. 性能优化（CPU、内存、带宽）
5. Bug修复
6. 文档完善

**验收标准**：
- 所有功能正常工作
- 12人同屏流畅运行（服务端30Hz，客户端60FPS）
- 网络延迟100ms下体验良好
- 无严重Bug

### 20.2 总时间估算

**总计**：15-21天（约3-4周）

### 20.3 依赖关系

```
阶段1（移动系统）
    ↓
阶段2（阵营和目标选择）
    ↓
阶段3（武器系统）
    ↓
阶段4（行为树系统）
    ↓
阶段5（相机系统）
    ↓
阶段6（集成测试）
```

**并行可能性**：
- 阶段5（相机系统）可以与阶段4（行为树系统）并行开发
- 阶段2（阵营）和阶段3（武器）部分工作可以并行

### 20.4 风险识别

#### 风险1：客户端预测误差过大

**影响**：移动体验差，频繁回正

**缓解措施**：
- 优化预测算法
- 调整回正阈值
- 增加服务端Tick频率

#### 风险2：NavMesh性能问题

**影响**：服务端CPU占用过高

**缓解措施**：
- 条件回贴（移动>1米才查询）
- 异步NavMesh查询
- 降低Tick频率

#### 风险3：BT性能开销

**影响**：大量Unit时服务端卡顿

**缓解措施**：
- BT节点优化
- 减少不必要的检查
- 使用对象池

#### 风险4：网络带宽占用

**影响**：大量玩家时带宽不足

**缓解措施**：
- 只在状态变化时广播
- 降低广播频率
- 使用增量同步

---

## 21. 性能指标

### 21.1 服务端性能目标

- **Tick频率**：30Hz（33ms/Tick）
- **单Unit移动开销**：<0.5ms/Tick
- **单Unit BT开销**：<2ms/Tick
- **12人同屏总开销**：<30ms/Tick（单核）
- **内存占用**：<100MB（12人）

### 21.2 客户端性能目标

- **帧率**：60FPS（16.6ms/帧）
- **输入延迟**：<50ms（本地预测）
- **网络延迟容忍**：100ms下体验良好
- **内存占用**：<200MB

### 21.3 网络性能目标

- **上行带宽**：<1KB/s/玩家
- **下行带宽**：<30KB/s/玩家（12人同屏）
- **丢包容忍**：50%丢包率下可用

---

## 22. 测试计划

### 22.1 单元测试

- MoveComponent模式切换
- Seq溢出处理
- 阵营关系判断
- 目标选择算法
- 弹药管理
- BT节点逻辑

### 22.2 集成测试

- 摇杆移动 + 客户端预测
- 目标选择 + 自动射击
- 武器BT + Buff系统
- 移动 + 射击（步枪静止、冲锋枪移动）

### 22.3 压力测试

- 12人同屏移动
- 12人同屏战斗
- 长时间运行（24小时）
- 网络抖动测试

### 22.4 兼容性测试

- 不同网络环境（WiFi、4G、5G）
- 不同延迟（50ms、100ms、200ms）
- 不同丢包率（0%、10%、30%、50%）

---

## 23. 配置表汇总

### 23.1 JoystickMoveConfig

```csharp
public class JoystickMoveConfig
{
    public int Id;
    public int ServerTickMs = 33;           // 服务端Tick间隔（30Hz）
    public int SyncIntervalMs = 100;        // 广播间隔（10Hz）
    public float MaxSpeed = 10.0f;          // 最大移动速度（m/s）
    public int InputTimeoutMs = 1000;       // 输入超时时间（ms）
    public float NavMeshCheckDist = 1.0f;   // NavMesh检查距离阈值（m）
}
```

### 23.2 CampConfig

```csharp
public class CampConfig
{
    public int Id;
    public string Name;
    public CampType Type;
    public int[] EnemyCamps;
}
```

### 23.3 TargetSelectorConfig

```csharp
public class TargetSelectorConfig
{
    public int Id;
    public int SelectIntervalMs = 500;
    public float MaxRange = 10.0f;
    public float DistanceWeight = 0.7f;
    public float HpWeight = 0.3f;
    public float AttackMeBonus = 0.5f;
}
```

### 23.4 WeaponConfig

```csharp
public class WeaponConfig
{
    public int Id;
    public string Name;
    public WeaponType Type;
    public float Damage;
    public float AttackRange;
    public float AttackInterval;
    public int MagazineSize;
    public float ReloadTime;
    public bool CanMoveWhileFire;
    public int BTConfigId;
    public string ProjectilePrefab;
}
```

### 23.5 CameraConfig

```csharp
public class CameraConfig
{
    public int Id;
    public bool IsFixedTopDown = true;
    public float FixedPitch = 60f;
    public float FixedDistance = 10f;
    public float FixedHeight = 8f;
    public float FollowDamping = 0.5f;
    public float LookDamping = 0.5f;
}
```

---

## 24. 关键代码文件清单

### 24.1 移动系统

- `MoveComponent.cs` - 移动组件（扩展）
- `MoveComponentSystem.cs` - 移动系统（扩展）
- `InputSystemComponent.cs` - 输入系统（新增）
- `C2M_JoystickInput.proto` - 输入协议（新增）
- `M2C_JoystickState.proto` - 状态协议（新增）
- `C2M_JoystickInputHandler.cs` - 输入处理（新增）
- `M2C_JoystickStateHandler.cs` - 状态处理（新增）

### 24.2 战斗系统

- `CampComponent.cs` - 阵营组件（新增）
- `CampHelper.cs` - 阵营工具（新增）
- `TargetSelectorComponent.cs` - 目标选择器（新增）
- `WeaponComponent.cs` - 武器组件（新增）
- `BulletComponent.cs` - 子弹组件（新增）
- `C2M_SwitchTarget.proto` - 切换目标协议（新增）

### 24.3 行为树系统

- `BTComponent.cs` - BT组件（新增）
- `BTNode.cs` - BT节点基类（新增）
- `BTContext.cs` - BT上下文（新增）
- `BTCondition.cs` - 条件节点基类（新增）
- `BTAction.cs` - 行动节点基类（新增）
- `BTComposite.cs` - 组合节点基类（新增）
- `CheckHasTarget.cs` - 检查目标节点（新增）
- `CheckInRange.cs` - 检查范围节点（新增）
- `CheckNotMoving.cs` - 检查静止节点（新增）
- `AimAtTarget.cs` - 瞄准节点（新增）
- `SpawnBullet.cs` - 生成子弹节点（新增）
- 等等...

### 24.4 相机系统

- `CinemachineComponent.cs` - 相机组件（扩展）
- `CinemachineComponentSystem.cs` - 相机系统（扩展）

---

## 25. 总结

本技术方案基于ET Framework，设计了一个完整的竖屏射击游戏战斗系统，包括：

1. **摇杆移动系统**：服务端权威，客户端预测，30Hz Tick，支持12人同屏
2. **阵营系统**：友方/敌方/中立，支持复杂阵营关系
3. **目标选择系统**：自动选择最优目标，支持手动切换
4. **武器系统**：双武器（步枪+冲锋枪），独立弹药管理
5. **行为树系统**：灵活的BT框架，支持复杂武器逻辑
6. **相机系统**：固定俯视相机，平滑跟随

**核心优势**：
- 统一MoveComponent，避免组件冲突
- 客户端预测，操作手感好
- 条件NavMesh回贴，性能优化
- BT驱动武器，易扩展
- 配置化设计，易调整

**预计工期**：3-4周

**风险可控**：已识别主要风险并提供缓解措施

---

**文档版本**：v1.0
**创建日期**：2026-03-01
**作者**：Claude Code
**状态**：待评审
