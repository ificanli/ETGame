# 战斗操作和相机操作技术方案 - 第4部分：战斗系统

## 11. 阵营系统设计

### 11.1 CampComponent

```csharp
[ComponentOf(typeof(Unit))]
public class CampComponent: Entity, IAwake<int>
{
    public int CampId;              // 阵营ID
    public CampType CampType;       // 阵营类型
}

public enum CampType
{
    Friendly = 1,   // 友方
    Enemy = 2,      // 敌方
    Neutral = 3     // 中立
}
```

### 11.2 CampComponent系统

```csharp
[EntitySystemOf(typeof(CampComponent))]
public static partial class CampComponentSystem
{
    [EntitySystem]
    private static void Awake(this CampComponent self, int campId)
    {
        self.CampId = campId;

        // 从配置表读取阵营类型
        CampConfig config = CampConfigCategory.Instance.Get(campId);
        if (config != null)
        {
            self.CampType = config.Type;
        }
        else
        {
            self.CampType = CampType.Neutral;
        }
    }
}
```

### 11.3 阵营关系判断

```csharp
public static class CampHelper
{
    // 判断两个单位是否敌对
    public static bool IsEnemy(Unit unit1, Unit unit2)
    {
        if (unit1 == null || unit2 == null)
            return false;

        CampComponent camp1 = unit1.GetComponent<CampComponent>();
        CampComponent camp2 = unit2.GetComponent<CampComponent>();

        if (camp1 == null || camp2 == null)
            return false;

        // 中立阵营不与任何人敌对
        if (camp1.CampType == CampType.Neutral || camp2.CampType == CampType.Neutral)
            return false;

        // 不同阵营且都不是中立，则敌对
        return camp1.CampId != camp2.CampId;
    }

    // 判断是否友方
    public static bool IsFriendly(Unit unit1, Unit unit2)
    {
        if (unit1 == null || unit2 == null)
            return false;

        CampComponent camp1 = unit1.GetComponent<CampComponent>();
        CampComponent camp2 = unit2.GetComponent<CampComponent>();

        if (camp1 == null || camp2 == null)
            return false;

        return camp1.CampId == camp2.CampId;
    }

    // 判断是否中立
    public static bool IsNeutral(Unit unit)
    {
        if (unit == null)
            return false;

        CampComponent camp = unit.GetComponent<CampComponent>();
        if (camp == null)
            return false;

        return camp.CampType == CampType.Neutral;
    }

    // 获取阵营关系
    public static CampRelation GetRelation(Unit unit1, Unit unit2)
    {
        if (IsFriendly(unit1, unit2))
            return CampRelation.Friendly;
        if (IsEnemy(unit1, unit2))
            return CampRelation.Enemy;
        return CampRelation.Neutral;
    }
}

public enum CampRelation
{
    Friendly,   // 友方
    Enemy,      // 敌方
    Neutral     // 中立
}
```

### 11.4 配置表

```csharp
// CampConfig.xlsx
public class CampConfig
{
    public int Id;              // 阵营ID
    public string Name;         // 阵营名称
    public CampType Type;       // 阵营类型
    public int[] EnemyCamps;    // 敌对阵营列表（可选，用于复杂阵营关系）
}
```

---

## 12. 目标选择系统设计

### 12.1 TargetSelectorComponent

```csharp
[ComponentOf(typeof(Unit))]
public class TargetSelectorComponent: Entity, IAwake
{
    public long CurrentTargetId;        // 当前目标ID
    public long ManualTargetId;         // 手动指定的目标ID
    public long LastSelectTime;         // 上次选择目标时间
    public int SelectInterval = 500;    // 选择间隔（ms）
    public float MaxRange = 10.0f;      // 最大索敌范围
}
```

### 12.2 TargetSelector系统

```csharp
[EntitySystemOf(typeof(TargetSelectorComponent))]
public static partial class TargetSelectorComponentSystem
{
    [EntitySystem]
    private static void Awake(this TargetSelectorComponent self)
    {
        self.CurrentTargetId = 0;
        self.ManualTargetId = 0;
        self.LastSelectTime = 0;

        // 从配置读取
        TargetSelectorConfig config = TargetSelectorConfigCategory.Instance.Get(1);
        if (config != null)
        {
            self.SelectInterval = config.SelectIntervalMs;
            self.MaxRange = config.MaxRange;
        }
    }

    // 选择目标
    public static Unit SelectTarget(this TargetSelectorComponent self)
    {
        Unit owner = self.GetParent<Unit>();

        // 检查选择间隔
        long now = TimeInfo.Instance.ServerNow();
        if (now - self.LastSelectTime < self.SelectInterval)
        {
            // 返回当前目标
            if (self.CurrentTargetId != 0)
            {
                return owner.Scene().GetComponent<UnitComponent>().Get(self.CurrentTargetId);
            }
            return null;
        }

        self.LastSelectTime = now;

        // 1. 优先使用手动指定的目标
        if (self.ManualTargetId != 0)
        {
            Unit manualTarget = owner.Scene().GetComponent<UnitComponent>().Get(self.ManualTargetId);
            if (manualTarget != null && IsValidTarget(owner, manualTarget, self.MaxRange))
            {
                self.CurrentTargetId = self.ManualTargetId;
                return manualTarget;
            }
            else
            {
                // 手动目标无效，清除
                self.ManualTargetId = 0;
            }
        }

        // 2. 自动选择目标
        Unit bestTarget = FindBestTarget(owner, self.MaxRange);
        if (bestTarget != null)
        {
            self.CurrentTargetId = bestTarget.Id;
            return bestTarget;
        }

        // 3. 没有目标
        self.CurrentTargetId = 0;
        return null;
    }

    // 查找最佳目标
    private static Unit FindBestTarget(Unit owner, float maxRange)
    {
        List<Unit> enemies = GetEnemiesInRange(owner, maxRange);
        if (enemies.Count == 0)
            return null;

        // 优先级排序：
        // 1. 距离最近的敌人
        // 2. 血量最低的敌人
        // 3. 正在攻击自己的敌人

        TargetSelectorConfig config = TargetSelectorConfigCategory.Instance.Get(1);
        float distanceWeight = config?.DistanceWeight ?? 0.7f;
        float hpWeight = config?.HpWeight ?? 0.3f;
        float attackMeBonus = config?.AttackMeBonus ?? 0.5f;

        Unit bestTarget = null;
        float bestScore = float.MaxValue;

        foreach (Unit enemy in enemies)
        {
            float distance = math.distance(owner.Position, enemy.Position);

            NumericComponent numericComp = enemy.GetComponent<NumericComponent>();
            float hp = numericComp.GetAsFloat(NumericType.Hp);
            float maxHp = numericComp.GetAsFloat(NumericType.MaxHp);
            float hpPercent = maxHp > 0 ? hp / maxHp : 0;

            // 计算评分（距离权重0.7，血量权重0.3）
            float score = distance * distanceWeight + hpPercent * maxRange * hpWeight;

            // 如果正在攻击自己，降低评分（提高优先级）
            if (IsAttackingMe(enemy, owner))
            {
                score *= attackMeBonus;
            }

            if (score < bestScore)
            {
                bestScore = score;
                bestTarget = enemy;
            }
        }

        return bestTarget;
    }

    // 获取范围内的敌人
    private static List<Unit> GetEnemiesInRange(Unit owner, float range)
    {
        List<Unit> result = new List<Unit>();
        List<AOIEntity> aoiEntities = owner.GetBeSeePlayers();

        foreach (AOIEntity aoiEntity in aoiEntities)
        {
            if (aoiEntity.Unit == null)
                continue;

            Unit target = aoiEntity.Unit;

            // 检查是否敌对
            if (!CampHelper.IsEnemy(owner, target))
                continue;

            // 检查距离
            float distance = math.distance(owner.Position, target.Position);
            if (distance > range)
                continue;

            // 检查是否存活
            NumericComponent numericComp = target.GetComponent<NumericComponent>();
            if (numericComp.GetAsFloat(NumericType.Hp) <= 0)
                continue;

            result.Add(target);
        }

        return result;
    }

    // 检查目标是否有效
    private static bool IsValidTarget(Unit owner, Unit target, float maxRange)
    {
        if (target == null)
            return false;

        // 检查是否敌对
        if (!CampHelper.IsEnemy(owner, target))
            return false;

        // 检查距离
        float distance = math.distance(owner.Position, target.Position);
        if (distance > maxRange)
            return false;

        // 检查是否存活
        NumericComponent numericComp = target.GetComponent<NumericComponent>();
        if (numericComp.GetAsFloat(NumericType.Hp) <= 0)
            return false;

        return true;
    }

    // 检查敌人是否正在攻击自己
    private static bool IsAttackingMe(Unit enemy, Unit me)
    {
        TargetSelectorComponent enemySelector = enemy.GetComponent<TargetSelectorComponent>();
        if (enemySelector == null)
            return false;

        return enemySelector.CurrentTargetId == me.Id;
    }

    // 手动切换目标
    public static void SetManualTarget(this TargetSelectorComponent self, long targetId)
    {
        self.ManualTargetId = targetId;
        self.LastSelectTime = 0;  // 重置时间，立即选择
        self.SelectTarget();
    }

    // 获取当前目标
    public static Unit GetCurrentTarget(this TargetSelectorComponent self)
    {
        if (self.CurrentTargetId == 0)
            return null;

        return self.GetParent<Unit>().Scene().GetComponent<UnitComponent>().Get(self.CurrentTargetId);
    }
}
```

### 12.3 配置表

```csharp
// TargetSelectorConfig.xlsx
public class TargetSelectorConfig
{
    public int Id;
    public int SelectIntervalMs = 1000;     // 选择间隔（ms）改为1秒
    public float MaxRange = 10.0f;          // 最大索敌范围（m）
    public float DistanceWeight = 0.7f;     // 距离权重
    public float HpWeight = 0.3f;           // 血量权重
    public float AttackMeBonus = 0.5f;      // 攻击自己的优先级加成
}
```

---

## 13. 武器系统设计

### 13.1 WeaponComponent

```csharp
[ComponentOf(typeof(Unit))]
public class WeaponComponent: Entity, IAwake<int, int>
{
    public int RifleId;                 // 步枪ID
    public int SMGId;                   // 冲锋枪ID
    public WeaponType CurrentWeapon = WeaponType.Rifle;  // 当前装备武器
    public int RifleAmmo;               // 步枪当前弹药
    public int SMGAmmo;                 // 冲锋枪当前弹药
    public bool RifleReloading;         // 步枪是否在换弹
    public bool SMGReloading;           // 冲锋枪是否在换弹
    public long RifleLastFireTime;      // 步枪上次射击时间
    public long SMGLastFireTime;        // 冲锋枪上次射击时间
}
```

### 13.2 Weapon系统

```csharp
[EntitySystemOf(typeof(WeaponComponent))]
public static partial class WeaponComponentSystem
{
    [EntitySystem]
    private static void Awake(this WeaponComponent self, int rifleId, int smgId)
    {
        self.RifleId = rifleId;
        self.SMGId = smgId;

        // 初始化弹药
        WeaponConfig rifleConfig = WeaponConfigCategory.Instance.Get(rifleId);
        WeaponConfig smgConfig = WeaponConfigCategory.Instance.Get(smgId);

        self.RifleAmmo = rifleConfig?.MagazineSize ?? 30;
        self.SMGAmmo = smgConfig?.MagazineSize ?? 40;

        self.RifleReloading = false;
        self.SMGReloading = false;
        self.RifleLastFireTime = 0;
        self.SMGLastFireTime = 0;
    }

    // 获取弹药
    public static int GetAmmo(this WeaponComponent self, int weaponId)
    {
        if (weaponId == self.RifleId)
            return self.RifleAmmo;
        if (weaponId == self.SMGId)
            return self.SMGAmmo;
        return 0;
    }

    // 消耗弹药
    public static void ConsumeAmmo(this WeaponComponent self, int weaponId, int count)
    {
        if (weaponId == self.RifleId)
        {
            self.RifleAmmo = math.max(0, self.RifleAmmo - count);
        }
        else if (weaponId == self.SMGId)
        {
            self.SMGAmmo = math.max(0, self.SMGAmmo - count);
        }
    }

    // 补充弹药
    public static void RefillAmmo(this WeaponComponent self, int weaponId)
    {
        WeaponConfig config = WeaponConfigCategory.Instance.Get(weaponId);
        if (config == null)
            return;

        if (weaponId == self.RifleId)
        {
            self.RifleAmmo = config.MagazineSize;
        }
        else if (weaponId == self.SMGId)
        {
            self.SMGAmmo = config.MagazineSize;
        }
    }

    // 检查是否在换弹
    public static bool IsReloading(this WeaponComponent self, int weaponId)
    {
        if (weaponId == self.RifleId)
            return self.RifleReloading;
        if (weaponId == self.SMGId)
            return self.SMGReloading;
        return false;
    }

    // 设置换弹状态
    public static void SetReloading(this WeaponComponent self, int weaponId, bool reloading)
    {
        if (weaponId == self.RifleId)
        {
            self.RifleReloading = reloading;
        }
        else if (weaponId == self.SMGId)
        {
            self.SMGReloading = reloading;
        }
    }

    // 检查是否可以射击
    public static bool CanFire(this WeaponComponent self, int weaponId)
    {
        // 检查弹药
        if (self.GetAmmo(weaponId) <= 0)
            return false;

        // 检查是否在换弹
        if (self.IsReloading(weaponId))
            return false;

        // 检查射击间隔
        WeaponConfig config = WeaponConfigCategory.Instance.Get(weaponId);
        if (config == null)
            return false;

        long now = TimeInfo.Instance.ServerNow();
        long lastFireTime = weaponId == self.RifleId ? self.RifleLastFireTime : self.SMGLastFireTime;
        long interval = now - lastFireTime;

        if (interval < config.AttackInterval * 1000)
            return false;

        return true;
    }

    // 记录射击时间
    public static void RecordFireTime(this WeaponComponent self, int weaponId)
    {
        long now = TimeInfo.Instance.ServerNow();

        if (weaponId == self.RifleId)
        {
            self.RifleLastFireTime = now;
        }
        else if (weaponId == self.SMGId)
        {
            self.SMGLastFireTime = now;
        }
    }
}
```

### 13.3 武器配置

```csharp
// WeaponConfig.xlsx
public class WeaponConfig
{
    public int Id;                  // 武器ID
    public string Name;             // 武器名称
    public WeaponType Type;         // 武器类型
    public float Damage;            // 伤害
    public float AttackRange;       // 攻击范围（m）
    public float AttackInterval;    // 攻击间隔（秒）
    public int MagazineSize;        // 弹匣容量
    public float ReloadTime;        // 换弹时间（秒）
    public bool CanMoveWhileFire;   // 是否可以边移动边射击
    public int BTConfigId;          // BT配置ID
    public string ProjectilePrefab; // 子弹预制体路径
}

public enum WeaponType
{
    Rifle = 1,      // 步枪（静止射击）
    SMG = 2         // 冲锋枪（移动射击）
}
```

---

## 14. 子弹系统

### 14.1 创建子弹

```csharp
public static class UnitFactory
{
    public static Unit CreateBullet(Scene scene, Unit owner, Unit target, WeaponConfig weaponConfig)
    {
        Unit bullet = scene.GetComponent<UnitComponent>().AddChildWithId<Unit, int>(IdGenerater.Instance.GenerateId(), 1);

        bullet.Position = owner.Position;
        bullet.AddComponent<BulletComponent, long, long, float>(owner.Id, target.Id, weaponConfig.Damage);

        return bullet;
    }
}
```

### 14.2 BulletComponent

```csharp
[ComponentOf(typeof(Unit))]
public class BulletComponent: Entity, IAwake<long, long, float>, IUpdate
{
    public long OwnerId;        // 发射者ID
    public long TargetId;       // 目标ID
    public float Damage;        // 伤害
    public float Speed = 20f;   // 子弹速度（m/s）
}

[EntitySystemOf(typeof(BulletComponent))]
public static partial class BulletComponentSystem
{
    [EntitySystem]
    private static void Awake(this BulletComponent self, long ownerId, long targetId, float damage)
    {
        self.OwnerId = ownerId;
        self.TargetId = targetId;
        self.Damage = damage;
    }

    [EntitySystem]
    private static void Update(this BulletComponent self)
    {
        Unit bullet = self.GetParent<Unit>();
        Unit target = bullet.Scene().GetComponent<UnitComponent>().Get(self.TargetId);

        if (target == null)
        {
            // 目标不存在，销毁子弹
            bullet.Dispose();
            return;
        }

        // 移动子弹
        float3 direction = target.Position - bullet.Position;
        float distance = math.length(direction);

        if (distance < 0.1f)
        {
            // 命中目标
            self.OnHit(target);
            bullet.Dispose();
            return;
        }

        float3 moveDir = math.normalize(direction);
        float moveDistance = self.Speed * Time.deltaTime;

        if (moveDistance >= distance)
        {
            // 本帧会命中
            bullet.Position = target.Position;
            self.OnHit(target);
            bullet.Dispose();
        }
        else
        {
            bullet.Position += moveDir * moveDistance;
        }
    }

    private static void OnHit(this BulletComponent self, Unit target)
    {
        Unit owner = self.GetParent<Unit>().Scene().GetComponent<UnitComponent>().Get(self.OwnerId);

        // 造成伤害
        target.GetComponent<NumericComponent>().ApplyChange(NumericType.Hp, -self.Damage);

        // 发送伤害消息
        M2C_Damage msg = M2C_Damage.Create();
        msg.AttackerId = self.OwnerId;
        msg.TargetId = target.Id;
        msg.Damage = self.Damage;

        MessageHelper.SendToAOI(target, msg);
    }
}
```

---
