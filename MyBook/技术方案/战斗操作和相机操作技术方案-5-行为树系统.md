# 战斗操作和相机操作技术方案 - 第5部分：行为树系统

## 15. 行为树架构

### 15.1 BTComponent

```csharp
[ComponentOf(typeof(Unit))]
public class BTComponent: Entity, IAwake<int>, IUpdate
{
    public int ConfigId;            // BT配置ID
    public BTNode RootNode;         // 根节点
    public BTContext Context;       // 上下文
    public BTStatus Status;         // 当前状态
    public int BTTickInterval = 100;  // BT执行间隔（ms）
    public long LastBTTickTime;       // 上次执行时间
}

public enum BTStatus
{
    Running,    // 运行中
    Success,    // 成功
    Failure     // 失败
}
```

### 15.2 BTContext

```csharp
public class BTContext
{
    private Unit unit;
    private Dictionary<string, object> blackboard = new Dictionary<string, object>();

    public BTContext(Unit unit)
    {
        this.unit = unit;
    }

    public Unit GetUnit() => unit;

    public void Set(string key, object value)
    {
        blackboard[key] = value;
    }

    public T Get<T>(string key)
    {
        if (blackboard.TryGetValue(key, out object value))
        {
            return (T)value;
        }
        return default(T);
    }

    public void SetTarget(Unit target)
    {
        Set("Target", target);
    }

    public Unit GetTarget()
    {
        return Get<Unit>("Target");
    }

    public void SetInt(string key, int value)
    {
        Set(key, value);
    }

    public int GetInt(string key)
    {
        return Get<int>(key);
    }
}
```

### 15.3 BTNode基类

```csharp
public abstract class BTNode
{
    public abstract BTStatus Tick(BTContext context);
}

// 条件节点
public abstract class BTCondition: BTNode
{
    public override BTStatus Tick(BTContext context)
    {
        return Check(context) ? BTStatus.Success : BTStatus.Failure;
    }

    protected abstract bool Check(BTContext context);
}

// 行动节点
public abstract class BTAction: BTNode
{
    private BTStatus status = BTStatus.Running;

    public override BTStatus Tick(BTContext context)
    {
        if (status == BTStatus.Running)
        {
            status = OnUpdate(context);
        }

        if (status != BTStatus.Running)
        {
            OnExit(context);
        }

        return status;
    }

    protected abstract BTStatus OnUpdate(BTContext context);

    protected virtual void OnExit(BTContext context) { }

    public void Reset()
    {
        status = BTStatus.Running;
    }
}

// 组合节点
public abstract class BTComposite: BTNode
{
    protected List<BTNode> children = new List<BTNode>();

    public void AddChild(BTNode child)
    {
        children.Add(child);
    }
}
```

### 15.4 组合节点实现

#### 15.4.1 Sequence（顺序执行）

```csharp
public class BTSequence: BTComposite
{
    private int currentIndex = 0;

    public override BTStatus Tick(BTContext context)
    {
        while (currentIndex < children.Count)
        {
            BTStatus status = children[currentIndex].Tick(context);

            if (status == BTStatus.Failure)
            {
                currentIndex = 0;
                return BTStatus.Failure;
            }

            if (status == BTStatus.Running)
            {
                return BTStatus.Running;
            }

            // Success，继续下一个
            currentIndex++;
        }

        // 所有子节点都成功
        currentIndex = 0;
        return BTStatus.Success;
    }
}
```

#### 15.4.2 Selector（选择执行）

```csharp
public class BTSelector: BTComposite
{
    private int currentIndex = 0;

    public override BTStatus Tick(BTContext context)
    {
        while (currentIndex < children.Count)
        {
            BTStatus status = children[currentIndex].Tick(context);

            if (status == BTStatus.Success)
            {
                currentIndex = 0;
                return BTStatus.Success;
            }

            if (status == BTStatus.Running)
            {
                return BTStatus.Running;
            }

            // Failure，尝试下一个
            currentIndex++;
        }

        // 所有子节点都失败
        currentIndex = 0;
        return BTStatus.Failure;
    }
}
```

#### 15.4.3 Parallel（并行执行）

```csharp
public class BTParallel: BTComposite
{
    public override BTStatus Tick(BTContext context)
    {
        bool hasRunning = false;
        bool hasFailure = false;

        foreach (BTNode child in children)
        {
            BTStatus status = child.Tick(context);

            if (status == BTStatus.Running)
            {
                hasRunning = true;
            }
            else if (status == BTStatus.Failure)
            {
                hasFailure = true;
            }
        }

        if (hasFailure)
            return BTStatus.Failure;

        if (hasRunning)
            return BTStatus.Running;

        return BTStatus.Success;
    }
}
```

---

## 16. 武器BT节点实现

### 16.1 条件节点

#### 16.1.1 CheckHasTarget

```csharp
[BTNode("检查是否有目标")]
public class CheckHasTarget: BTCondition
{
    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        TargetSelectorComponent selector = unit.GetComponent<TargetSelectorComponent>();

        if (selector == null)
            return false;

        Unit target = selector.SelectTarget();
        if (target == null)
            return false;

        context.SetTarget(target);
        return true;
    }
}
```

#### 16.1.2 CheckInRange

```csharp
[BTNode("检查目标是否在范围内")]
public class CheckInRange: BTCondition
{
    public float Range;  // 从配置读取

    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        Unit target = context.GetTarget();

        if (target == null)
            return false;

        float distance = math.distance(unit.Position, target.Position);
        return distance <= Range;
    }
}
```

#### 16.1.3 CheckNotMoving

```csharp
[BTNode("检查是否静止")]
public class CheckNotMoving: BTCondition
{
    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        MoveComponent moveComp = unit.GetComponent<MoveComponent>();

        if (moveComp == null)
            return true;

        // 检查是否在移动
        if (moveComp.Mode == MoveMode.Joystick)
        {
            // 摇杆模式：检查方向是否为零
            return math.lengthsq(moveComp.JoystickDir) < 0.01f;
        }
        else if (moveComp.Mode == MoveMode.Path)
        {
            // 路径模式：检查是否到达
            return moveComp.IsArrived();
        }

        return true;
    }
}
```

#### 16.1.4 CheckAmmo

```csharp
[BTNode("检查弹药")]
public class CheckAmmo: BTCondition
{
    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();

        if (weaponComp == null)
            return false;

        int weaponId = context.GetInt("WeaponId");
        int currentAmmo = weaponComp.GetAmmo(weaponId);

        return currentAmmo > 0;
    }
}
```

#### 16.1.5 CheckNotReloading

```csharp
[BTNode("检查是否未在换弹")]
public class CheckNotReloading: BTCondition
{
    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();

        if (weaponComp == null)
            return true;

        int weaponId = context.GetInt("WeaponId");
        return !weaponComp.IsReloading(weaponId);
    }
}
```

#### 16.1.6 CheckNeedReload

```csharp
[BTNode("检查是否需要换弹")]
public class CheckNeedReload: BTCondition
{
    protected override bool Check(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();

        if (weaponComp == null)
            return false;

        int weaponId = context.GetInt("WeaponId");
        int currentAmmo = weaponComp.GetAmmo(weaponId);

        return currentAmmo <= 0;
    }
}
```

### 16.2 行动节点

#### 16.2.1 AimAtTarget

```csharp
[BTNode("瞄准目标")]
public class AimAtTarget: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        Unit target = context.GetTarget();

        if (target == null)
            return BTStatus.Failure;

        // 计算朝向
        float3 direction = target.Position - unit.Position;
        direction.y = 0;

        if (math.lengthsq(direction) < 0.01f)
            return BTStatus.Success;

        // 设置朝向
        unit.Rotation = quaternion.LookRotation(math.normalize(direction), math.up());

        return BTStatus.Success;
    }
}
```

#### 16.2.2 PlayFireAnimation

```csharp
[BTNode("播放射击动画")]
public class PlayFireAnimation: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        int weaponId = context.GetInt("WeaponId");

        // 发送动画消息给客户端
        M2C_PlayAnimation msg = M2C_PlayAnimation.Create();
        msg.UnitId = unit.Id;
        msg.AnimationName = "Fire";
        msg.WeaponId = weaponId;

        MessageHelper.SendToAOI(unit, msg);

        return BTStatus.Success;
    }
}
```

#### 16.2.3 SpawnBullet

```csharp
[BTNode("生成子弹")]
public class SpawnBullet: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        Unit target = context.GetTarget();
        int weaponId = context.GetInt("WeaponId");

        if (target == null)
            return BTStatus.Failure;

        WeaponConfig config = WeaponConfigCategory.Instance.Get(weaponId);
        if (config == null)
            return BTStatus.Failure;

        // 创建子弹
        Unit bullet = UnitFactory.CreateBullet(unit.Scene(), unit, target, config);

        // 发送子弹生成消息给客户端
        M2C_CreateBullet msg = M2C_CreateBullet.Create();
        msg.BulletId = bullet.Id;
        msg.OwnerId = unit.Id;
        msg.TargetId = target.Id;
        msg.StartPos = unit.Position;
        msg.WeaponId = weaponId;

        MessageHelper.SendToAOI(unit, msg);

        return BTStatus.Success;
    }
}
```

#### 16.2.4 ConsumeAmmo

```csharp
[BTNode("消耗弹药")]
public class ConsumeAmmo: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();
        int weaponId = context.GetInt("WeaponId");

        if (weaponComp == null)
            return BTStatus.Failure;

        weaponComp.ConsumeAmmo(weaponId, 1);
        weaponComp.RecordFireTime(weaponId);

        return BTStatus.Success;
    }
}
```

#### 16.2.5 Wait

```csharp
[BTNode("等待")]
public class BTWait: BTAction
{
    public float Duration;  // 等待时长（秒）
    private long startTime;

    protected override BTStatus OnUpdate(BTContext context)
    {
        if (startTime == 0)
        {
            startTime = TimeInfo.Instance.ServerNow();
        }

        long now = TimeInfo.Instance.ServerNow();
        long elapsed = now - startTime;

        if (elapsed >= Duration * 1000)
        {
            return BTStatus.Success;
        }

        return BTStatus.Running;
    }

    protected override void OnExit(BTContext context)
    {
        startTime = 0;
    }
}
```

#### 16.2.6 SetReloadingState

```csharp
[BTNode("设置换弹状态")]
public class SetReloadingState: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();
        int weaponId = context.GetInt("WeaponId");

        if (weaponComp == null)
            return BTStatus.Failure;

        weaponComp.SetReloading(weaponId, true);

        return BTStatus.Success;
    }
}
```

#### 16.2.7 ClearReloadingState

```csharp
[BTNode("清除换弹状态")]
public class ClearReloadingState: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();
        int weaponId = context.GetInt("WeaponId");

        if (weaponComp == null)
            return BTStatus.Failure;

        weaponComp.SetReloading(weaponId, false);

        return BTStatus.Success;
    }
}
```

#### 16.2.8 RefillAmmo

```csharp
[BTNode("补充弹药")]
public class RefillAmmo: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weaponComp = unit.GetComponent<WeaponComponent>();
        int weaponId = context.GetInt("WeaponId");

        if (weaponComp == null)
            return BTStatus.Failure;

        weaponComp.RefillAmmo(weaponId);

        return BTStatus.Success;
    }
}
```

#### 16.2.9 PlayReloadAnimation

```csharp
[BTNode("播放换弹动画")]
public class PlayReloadAnimation: BTAction
{
    protected override BTStatus OnUpdate(BTContext context)
    {
        Unit unit = context.GetUnit();
        int weaponId = context.GetInt("WeaponId");

        // 发送动画消息给客户端
        M2C_PlayAnimation msg = M2C_PlayAnimation.Create();
        msg.UnitId = unit.Id;
        msg.AnimationName = "Reload";
        msg.WeaponId = weaponId;

        MessageHelper.SendToAOI(unit, msg);

        return BTStatus.Success;
    }
}
```

---

## 17. 武器BT结构

### 17.1 步枪BT（静止射击）

```csharp
public static BTNode CreateRifleBT(WeaponConfig config)
{
    BTSequence root = new BTSequence();

    // 1. 检查是否有目标
    root.AddChild(new CheckHasTarget());

    // 2. 检查目标是否在范围内
    CheckInRange checkRange = new CheckInRange();
    checkRange.Range = config.AttackRange;
    root.AddChild(checkRange);

    // 3. 检查是否静止（步枪关键条件）
    root.AddChild(new CheckNotMoving());

    // 4. 检查弹药
    root.AddChild(new CheckAmmo());

    // 5. 并行：瞄准 + 射击
    BTParallel parallel = new BTParallel();

    // 瞄准
    parallel.AddChild(new AimAtTarget());

    // 射击序列
    BTSequence fireSequence = new BTSequence();
    fireSequence.AddChild(new PlayFireAnimation());
    fireSequence.AddChild(new SpawnBullet());
    fireSequence.AddChild(new ConsumeAmmo());

    BTWait wait = new BTWait();
    wait.Duration = config.AttackInterval;
    fireSequence.AddChild(wait);

    parallel.AddChild(fireSequence);
    root.AddChild(parallel);

    // 6. 检查是否需要换弹
    BTSelector reloadSelector = new BTSelector();

    // 如果不需要换弹，成功
    BTSequence noReloadSeq = new BTSequence();
    noReloadSeq.AddChild(new BTInverter(new CheckNeedReload()));
    reloadSelector.AddChild(noReloadSeq);

    // 如果需要换弹，执行换弹BT
    reloadSelector.AddChild(CreateReloadBT(config));

    root.AddChild(reloadSelector);

    return root;
}
```

### 17.2 冲锋枪BT（移动射击）

```csharp
public static BTNode CreateSMGBT(WeaponConfig config)
{
    BTSequence root = new BTSequence();

    // 1. 检查是否有目标
    root.AddChild(new CheckHasTarget());

    // 2. 检查目标是否在范围内
    CheckInRange checkRange = new CheckInRange();
    checkRange.Range = config.AttackRange;
    root.AddChild(checkRange);

    // 注意：没有 CheckNotMoving，可以边移动边射击

    // 3. 检查弹药
    root.AddChild(new CheckAmmo());

    // 4. 并行：瞄准 + 射击
    BTParallel parallel = new BTParallel();

    // 瞄准
    parallel.AddChild(new AimAtTarget());

    // 射击序列
    BTSequence fireSequence = new BTSequence();
    fireSequence.AddChild(new PlayFireAnimation());
    fireSequence.AddChild(new SpawnBullet());
    fireSequence.AddChild(new ConsumeAmmo());

    BTWait wait = new BTWait();
    wait.Duration = config.AttackInterval;
    fireSequence.AddChild(wait);

    parallel.AddChild(fireSequence);
    root.AddChild(parallel);

    // 5. 检查是否需要换弹
    BTSelector reloadSelector = new BTSelector();

    // 如果不需要换弹，成功
    BTSequence noReloadSeq = new BTSequence();
    noReloadSeq.AddChild(new BTInverter(new CheckNeedReload()));
    reloadSelector.AddChild(noReloadSeq);

    // 如果需要换弹，执行换弹BT
    reloadSelector.AddChild(CreateReloadBT(config));

    root.AddChild(reloadSelector);

    return root;
}
```

### 17.3 换弹BT

```csharp
public static BTNode CreateReloadBT(WeaponConfig config)
{
    BTSequence root = new BTSequence();

    // 1. 检查是否未在换弹
    root.AddChild(new CheckNotReloading());

    // 2. 设置换弹状态
    root.AddChild(new SetReloadingState());

    // 3. 播放换弹动画
    root.AddChild(new PlayReloadAnimation());

    // 4. 等待换弹时间
    BTWait wait = new BTWait();
    wait.Duration = config.ReloadTime;
    root.AddChild(wait);

    // 5. 补充弹药
    root.AddChild(new RefillAmmo());

    // 6. 清除换弹状态
    root.AddChild(new ClearReloadingState());

    return root;
}
```

### 17.4 BTInverter（反转节点）

```csharp
public class BTInverter: BTNode
{
    private BTNode child;

    public BTInverter(BTNode child)
    {
        this.child = child;
    }

    public override BTStatus Tick(BTContext context)
    {
        BTStatus status = child.Tick(context);

        if (status == BTStatus.Success)
            return BTStatus.Failure;
        if (status == BTStatus.Failure)
            return BTStatus.Success;

        return status;
    }
}
```

---

## 18. BT系统集成

### 18.1 BTComponent系统

```csharp
[EntitySystemOf(typeof(BTComponent))]
public static partial class BTComponentSystem
{
    [EntitySystem]
    private static void Awake(this BTComponent self, int configId)
    {
        self.ConfigId = configId;
        self.Context = new BTContext(self.GetParent<Unit>());
        self.Status = BTStatus.Running;

        // 从配置创建BT
        self.RootNode = CreateBTFromConfig(configId, self.Context);
    }

    [EntitySystem]
    private static void Update(this BTComponent self)
    {
        if (self.RootNode == null)
            return;

        // 限制BT执行频率（10Hz）
        long now = TimeInfo.Instance.ServerNow();
        if (now - self.LastBTTickTime < self.BTTickInterval)
            return;

        self.LastBTTickTime = now;
        self.Status = self.RootNode.Tick(self.Context);
    }

    private static BTNode CreateBTFromConfig(int configId, BTContext context)
    {
        // 根据配置ID创建对应的BT
        // 这里简化处理，实际应该从配置表读取
        WeaponConfig weaponConfig = WeaponConfigCategory.Instance.Get(configId);
        if (weaponConfig == null)
            return null;

        context.SetInt("WeaponId", weaponConfig.Id);

        if (weaponConfig.Type == WeaponType.Rifle)
        {
            return CreateRifleBT(weaponConfig);
        }
        else if (weaponConfig.Type == WeaponType.SMG)
        {
            return CreateSMGBT(weaponConfig);
        }

        return null;
    }
}
```

### 18.2 为Unit添加武器BT

```csharp
public static void InitWeaponBT(this Unit self, int rifleId, int smgId)
{
    WeaponComponent weaponComp = self.GetComponent<WeaponComponent>();
    if (weaponComp == null)
    {
        weaponComp = self.AddComponent<WeaponComponent, int, int>(rifleId, smgId);
    }

    // 只添加当前装备武器的BT
    int currentWeaponId = weaponComp.CurrentWeapon == WeaponType.Rifle ? rifleId : smgId;
    self.AddChild<BTComponent, int>(currentWeaponId);
}

// 切换武器
public static void SwitchWeapon(this Unit self, WeaponType weaponType)
{
    WeaponComponent weaponComp = self.GetComponent<WeaponComponent>();
    if (weaponComp == null)
        return;

    if (weaponComp.CurrentWeapon == weaponType)
        return;

    weaponComp.CurrentWeapon = weaponType;

    // 移除旧BT
    BTComponent oldBT = self.GetChild<BTComponent>();
    oldBT?.Dispose();

    // 添加新BT
    int weaponId = weaponType == WeaponType.Rifle ? weaponComp.RifleId : weaponComp.SMGId;
    self.AddChild<BTComponent, int>(weaponId);
}
```

---
