# 战斗操作和相机操作技术方案 - 第3部分：服务端实现

## 7. 服务端移动系统实现

### 7.1 输入处理Handler

```csharp
[MessageHandler(SceneType.Map)]
public class C2M_JoystickInputHandler : MessageHandler<Unit, C2M_JoystickInput>
{
    protected override async ETTask Run(Unit unit, C2M_JoystickInput message)
    {
        MoveComponent moveComp = unit.GetComponent<MoveComponent>();
        if (moveComp == null)
        {
            moveComp = unit.AddComponent<MoveComponent>();
        }

        // 检查输入频率限制
        long now = TimeInfo.Instance.ServerNow();
        long interval = now - moveComp.LastInputTime;
        if (interval < 40)  // 最高25Hz
        {
            return;  // 忽略过于频繁的输入
        }

        // 检查Seq是否更新
        if (!IsSeqNewer(message.Seq, moveComp.LastSeq))
        {
            return;  // 忽略旧的或重复的输入
        }

        // 校验方向合法性
        float dirLen = math.length(message.MoveDir);
        if (dirLen > 1.1f)
        {
            Log.Warning($"Invalid MoveDir length: {dirLen}, reject");
            return;
        }

        // 更新移动状态
        moveComp.LastSeq = message.Seq;
        moveComp.LastInputTime = now;
        moveComp.JoystickDir = message.MoveDir;
        moveComp.SpeedScale = 1.0f;  // 重置速度缩放

        // 如果是首次输入，启动摇杆移动
        if (moveComp.Mode != MoveMode.Joystick)
        {
            moveComp.StartJoystickMove();
        }

        await ETTask.CompletedTask;
    }

    // Seq循环比较（处理溢出）
    private static bool IsSeqNewer(int newSeq, int oldSeq)
    {
        int diff = newSeq - oldSeq;

        if (diff > 0 && diff < 1000)
            return true;
        if (diff < -2000000000)  // 溢出回滚
            return true;

        return false;
    }
}
```

### 7.2 启动摇杆移动

```csharp
public static void StartJoystickMove(this MoveComponent self)
{
    if (self.Mode == MoveMode.Path)
    {
        self.Stop(false);  // 停止路径移动
    }

    self.Mode = MoveMode.Joystick;
    self.JoystickDir = float3.zero;
    self.LastSeq = 0;
    self.LastInputTime = TimeInfo.Instance.ServerNow();
    self.SpeedScale = 1.0f;
    self.LastNavMeshPos = self.GetParent<Unit>().Position;
    self.LastSyncPos = self.GetParent<Unit>().Position;
    self.LastSyncDir = float3.zero;

    // 启动移动Timer（30Hz）
    TimerComponent timerComp = self.Root().GetComponent<TimerComponent>();
    self.MoveTimer = timerComp.NewRepeatedTimer(
        33,  // 33ms = 30Hz
        TimerInvokeType.JoystickMoveTimer,
        self
    );

    // 启动同步Timer（10Hz）
    self.SyncTimer = timerComp.NewRepeatedTimer(
        100,  // 100ms = 10Hz
        TimerInvokeType.JoystickSyncTimer,
        self
    );
}
```

### 7.3 服务端Tick移动

```csharp
[Invoke(TimerInvokeType.JoystickMoveTimer)]
public class JoystickMoveTimer: ATimer<MoveComponent>
{
    protected override void Run(MoveComponent self)
    {
        try
        {
            self.TickJoystickMove();
        }
        catch (Exception e)
        {
            Log.Error($"Joystick move timer error: {self.Id}\n{e}");
        }
    }
}

public static void TickJoystickMove(this MoveComponent self)
{
    Unit unit = self.GetParent<Unit>();

    // 检查是否可以移动
    if (!unit.CanMove())
    {
        return;  // 被眩晕、定身等Buff限制
    }

    // 检查输入超时
    self.CheckInputTimeout();

    // 如果没有输入或已停止，不移动
    if (math.lengthsq(self.JoystickDir) < 0.01f)
    {
        return;
    }

    // 计算移动
    float speed = unit.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
    speed = math.min(speed, 10.0f);  // 限制最大速度10m/s
    speed *= self.SpeedScale;  // 应用速度缩放（超时减速）

    float dt = 0.033f;  // 33ms
    float3 targetPos = unit.Position + self.JoystickDir * speed * dt;

    // 条件NavMesh回贴（优化性能）
    if (math.distance(targetPos, self.LastNavMeshPos) > 1.0f)
    {
        RecastPathComponent pathComp = unit.Scene().GetComponent<RecastPathComponent>();
        if (pathComp != null)
        {
            targetPos = pathComp.RecastFindNearestPoint(targetPos);
            self.LastNavMeshPos = targetPos;
        }
    }

    // 异常移动检测
    float3 oldPos = unit.Position;
    float distance = math.distance(oldPos, targetPos);
    float maxDistance = speed * dt * 1.5f;
    if (distance > maxDistance)
    {
        Log.Warning($"Abnormal movement detected: {distance}m > {maxDistance}m");
        return;  // 拒绝异常移动
    }

    // 更新位置
    unit.Position = targetPos;

    // 更新朝向
    if (math.lengthsq(self.JoystickDir) > 0.01f)
    {
        float3 faceDir = self.JoystickDir;
        faceDir.y = 0;
        if (math.lengthsq(faceDir) > 0.01f)
        {
            unit.Rotation = quaternion.LookRotation(math.normalize(faceDir), math.up());
        }
    }
}
```

### 7.4 输入超时处理

```csharp
private const int INPUT_TIMEOUT_WARNING = 500;   // 0.5秒，开始减速
private const int INPUT_TIMEOUT_STOP = 1000;     // 1秒，完全停止

public static void CheckInputTimeout(this MoveComponent self)
{
    long now = TimeInfo.Instance.ServerNow();
    long elapsed = now - self.LastInputTime;

    if (elapsed > INPUT_TIMEOUT_STOP)
    {
        // 完全停止
        self.JoystickDir = float3.zero;
        self.SpeedScale = 0f;
    }
    else if (elapsed > INPUT_TIMEOUT_WARNING)
    {
        // 逐渐减速
        float factor = 1.0f - (elapsed - INPUT_TIMEOUT_WARNING) / 500f;
        self.SpeedScale = math.max(0, factor);
    }
}
```

### 7.5 状态广播

```csharp
[Invoke(TimerInvokeType.JoystickSyncTimer)]
public class JoystickSyncTimer: ATimer<MoveComponent>
{
    protected override void Run(MoveComponent self)
    {
        try
        {
            self.BroadcastJoystickState();
        }
        catch (Exception e)
        {
            Log.Error($"Joystick sync timer error: {self.Id}\n{e}");
        }
    }
}

public static void BroadcastJoystickState(this MoveComponent self)
{
    Unit unit = self.GetParent<Unit>();

    // 只在状态变化时广播（优化带宽）
    if (math.distance(self.LastSyncPos, unit.Position) < 0.1f &&
        math.distance(self.LastSyncDir, self.JoystickDir) < 0.01f)
    {
        return;  // 状态未变化，不广播
    }

    self.LastSyncPos = unit.Position;
    self.LastSyncDir = self.JoystickDir;

    // 创建广播消息
    M2C_JoystickState msg = M2C_JoystickState.Create();
    msg.UnitId = unit.Id;
    msg.Position = unit.Position;
    msg.MoveDir = self.JoystickDir;
    msg.IsMoving = math.lengthsq(self.JoystickDir) > 0.01f;
    msg.Seq = self.LastSeq;

    // AOI广播
    MessageHelper.SendToAOI(unit, msg);
}
```

### 7.6 移动能力检查

```csharp
public static bool CanMove(this Unit self)
{
    // 检查Buff限制
    BuffComponent buffComp = self.GetComponent<BuffComponent>();
    if (buffComp != null)
    {
        // 眩晕
        if (buffComp.HasBuffType(BuffType.Stun))
            return false;

        // 定身
        if (buffComp.HasBuffType(BuffType.Root))
            return false;

        // 冰冻
        if (buffComp.HasBuffType(BuffType.Freeze))
            return false;
    }

    // 检查是否在施法
    SkillComponent skillComp = self.GetComponent<SkillComponent>();
    if (skillComp != null && skillComp.IsCasting())
    {
        // 某些技能施法时不能移动
        SkillConfig config = SkillConfigCategory.Instance.Get(skillComp.CurrentSkillId);
        if (config.InterruptMove)
            return false;
    }

    return true;
}
```

### 7.7 停止摇杆移动

```csharp
public static void StopJoystickMove(this MoveComponent self)
{
    if (self.Mode != MoveMode.Joystick)
        return;

    self.Mode = MoveMode.Path;
    self.JoystickDir = float3.zero;

    // 停止Timer
    TimerComponent timerComp = self.Root().GetComponent<TimerComponent>();
    if (timerComp != null)
    {
        timerComp.Remove(ref self.MoveTimer);
        timerComp.Remove(ref self.SyncTimer);
    }

    // 广播停止状态
    self.BroadcastJoystickState();
}
```

### 7.8 断线重连处理

```csharp
public static void OnReconnect(this Unit self)
{
    MoveComponent moveComp = self.GetComponent<MoveComponent>();
    if (moveComp != null && moveComp.Mode == MoveMode.Joystick)
    {
        // 停止移动
        moveComp.JoystickDir = float3.zero;
        moveComp.LastSeq = 0;

        // 发送当前状态给客户端
        M2C_JoystickState msg = M2C_JoystickState.Create();
        msg.UnitId = self.Id;
        msg.Position = self.Position;
        msg.MoveDir = float3.zero;
        msg.IsMoving = false;
        msg.Seq = 0;

        MessageHelper.SendToClient(self, msg);
    }
}
```

---

## 8. 模式切换逻辑

### 8.1 从路径移动切换到摇杆移动

```csharp
// 当收到摇杆输入时，自动从路径移动切换到摇杆移动
public static void StartJoystickMove(this MoveComponent self)
{
    if (self.Mode == MoveMode.Path)
    {
        // 停止路径移动
        self.Stop(false);

        // 发布移动停止事件
        Unit unit = self.GetParent<Unit>();
        EventSystem.Instance.Publish(self.Scene(), new MoveStop() { Unit = unit });
    }

    // 初始化摇杆移动
    self.Mode = MoveMode.Joystick;
    // ... 其他初始化代码
}
```

### 8.2 从摇杆移动切换到路径移动

```csharp
// 当调用MoveToAsync时，自动从摇杆移动切换到路径移动
public static async ETTask<bool> MoveToAsync(this MoveComponent self, List<float3> target, float speed, int turnTime = 100)
{
    if (self.Mode == MoveMode.Joystick)
    {
        // 停止摇杆移动
        self.StopJoystickMove();
    }

    // 清空旧的路径
    self.Stop(false);

    // 设置新路径
    foreach (float3 v in target)
    {
        self.Targets.Add(v);
    }

    self.Mode = MoveMode.Path;
    self.IsTurnHorizontal = true;
    self.TurnTime = turnTime;
    self.Speed = speed;
    self.tcs = ETTask<bool>.Create(true);

    Unit unit = self.GetParent<Unit>();
    EventSystem.Instance.Publish(self.Scene(), new MoveStart() { Unit = unit });

    self.StartMove();

    EntityRef<MoveComponent> selfRef = self;
    bool moveRet = await self.tcs;

    if (moveRet)
    {
        self = selfRef;
        EventSystem.Instance.Publish(self.Scene(), new MoveStop() { Unit = unit });
    }

    return moveRet;
}
```

### 8.3 技能位移打断摇杆移动

```csharp
// 技能施放时，如果技能有位移效果，临时停止摇杆移动
public static void OnSkillStart(this Unit self, int skillId)
{
    SkillConfig config = SkillConfigCategory.Instance.Get(skillId);

    if (config.HasDisplacement)
    {
        MoveComponent moveComp = self.GetComponent<MoveComponent>();
        if (moveComp != null && moveComp.Mode == MoveMode.Joystick)
        {
            // 暂停摇杆移动（不清除输入，技能结束后恢复）
            moveComp.JoystickDir = float3.zero;
        }
    }
}
```

---

## 9. 性能优化

### 9.1 NavMesh查询优化

```csharp
// 只在移动距离超过阈值时才进行NavMesh查询
public static void TickJoystickMove(this MoveComponent self)
{
    // ... 前面的代码

    // 条件NavMesh回贴
    if (math.distance(targetPos, self.LastNavMeshPos) > 1.0f)
    {
        // 只有移动超过1米才查询NavMesh
        RecastPathComponent pathComp = unit.Scene().GetComponent<RecastPathComponent>();
        if (pathComp != null)
        {
            targetPos = pathComp.RecastFindNearestPoint(targetPos);
            self.LastNavMeshPos = targetPos;
        }
    }

    // ... 后面的代码
}
```

### 9.2 广播优化

```csharp
// 只在状态变化时广播
public static void BroadcastJoystickState(this MoveComponent self)
{
    Unit unit = self.GetParent<Unit>();

    // 位置变化小于0.1米且方向变化小于0.01，不广播
    if (math.distance(self.LastSyncPos, unit.Position) < 0.1f &&
        math.distance(self.LastSyncDir, self.JoystickDir) < 0.01f)
    {
        return;
    }

    // ... 广播代码
}
```

### 9.3 输入频率限制

```csharp
// 服务端限制输入频率，防止恶意刷消息
public static async ETTask Run(Unit unit, C2M_JoystickInput message)
{
    MoveComponent moveComp = unit.GetComponent<MoveComponent>();

    long now = TimeInfo.Instance.ServerNow();
    long interval = now - moveComp.LastInputTime;

    if (interval < 40)  // 最高25Hz
    {
        return;  // 忽略过于频繁的输入
    }

    // ... 处理输入
}
```

---

## 10. 安全性

### 10.1 输入校验

```csharp
// 校验方向向量长度
float dirLen = math.length(message.MoveDir);
if (dirLen > 1.1f)  // 允许小误差
{
    Log.Warning($"Invalid MoveDir length: {dirLen}, reject");
    return;
}
```

### 10.2 速度限制

```csharp
// 限制最大速度
float speed = unit.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
speed = math.min(speed, 10.0f);  // 硬编码最大速度
```

### 10.3 异常移动检测

```csharp
// 检测单次移动距离是否异常
float distance = math.distance(oldPos, targetPos);
float maxDistance = speed * dt * 1.5f;  // 允许1.5倍理论距离
if (distance > maxDistance)
{
    Log.Warning($"Abnormal movement detected: {distance}m > {maxDistance}m");
    return;  // 拒绝异常移动
}
```

### 10.4 Seq防重放

```csharp
// 使用Seq防止重放攻击
if (!IsSeqNewer(message.Seq, moveComp.LastSeq))
{
    return;  // 忽略旧的或重复的输入
}
```

---
