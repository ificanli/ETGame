# 战斗操作和相机操作技术方案 - 问题修复文档

## 文档说明

本文档记录技术方案中发现的问题及修复方案，实施时请参考此文档进行修正。

---

## 1. 严重问题修复

### 问题1.1：同步Timer未保存引用（内存泄漏）

**原代码位置**：第3部分 - StartJoystickMove方法

**问题**：
```csharp
// 启动同步Timer（10Hz）
long syncTimer = timerComp.NewRepeatedTimer(
    100,  // 100ms = 10Hz
    TimerInvokeType.JoystickSyncTimer,
    self
);
// syncTimer变量未保存，无法停止Timer
```

**修复方案**：

1. 在MoveComponent中添加字段：
```csharp
[ComponentOf(typeof(Unit))]
public class MoveComponent: Entity, IAwake, IDestroy
{
    // ... 原有字段

    // 新增字段
    public long MoveTimer;
    public long SyncTimer;  // ← 添加这个字段
}
```

2. 修改StartJoystickMove方法：
```csharp
public static void StartJoystickMove(this MoveComponent self)
{
    // ... 前面的代码

    // 启动移动Timer（30Hz）
    TimerComponent timerComp = self.Root().GetComponent<TimerComponent>();
    self.MoveTimer = timerComp.NewRepeatedTimer(
        33,
        TimerInvokeType.JoystickMoveTimer,
        self
    );

    // 启动同步Timer（10Hz）
    self.SyncTimer = timerComp.NewRepeatedTimer(  // ← 保存到字段
        100,
        TimerInvokeType.JoystickSyncTimer,
        self
    );
}
```

3. 修改StopJoystickMove方法：
```csharp
public static void StopJoystickMove(this MoveComponent self)
{
    if (self.Mode != MoveMode.Joystick)
        return;

    self.Mode = MoveMode.Path;
    self.JoystickDir = float3.zero;

    // 停止Timer
    TimerComponent timerComp = self.Root().GetComponent<TimerComponent>();
    if (timerComp != null)
    {
        timerComp.Remove(ref self.MoveTimer);
        timerComp.Remove(ref self.SyncTimer);  // ← 添加这行
    }

    // 广播停止状态
    self.BroadcastJoystickState();
}
```

---

### 问题1.2：MoveComponent新增字段未初始化

**原代码位置**：第1部分 - MoveComponent扩展

**问题**：新增字段没有在Awake中初始化。

**修复方案**：

在MoveComponentSystem中添加初始化逻辑：
```csharp
[EntitySystem]
private static void Awake(this MoveComponent self)
{
    // 原有字段初始化
    self.StartTime = 0;
    self.StartPos = float3.zero;
    self.NeedTime = 0;
    self.MoveTimer = 0;
    self.tcs = null;
    self.Targets.Clear();
    self.Speed = 0;
    self.N = 0;
    self.TurnTime = 0;

    // 新增字段初始化
    self.Mode = MoveMode.Path;
    self.JoystickDir = float3.zero;
    self.LastSeq = 0;
    self.LastInputTime = 0;
    self.LastNavMeshPos = float3.zero;
    self.SpeedScale = 1.0f;
    self.LastSyncPos = float3.zero;
    self.LastSyncDir = float3.zero;
    self.SyncTimer = 0;
}
```

---

### 问题1.3：客户端预测位置更新逻辑错误

**原代码位置**：第2部分 - SendJoystickInput方法

**问题**：只在发送输入时更新一次位置，应该每帧持续预测。

**修复方案**：

1. 修改InputSystemComponent.Update方法：
```csharp
[EntitySystem]
private static void Update(this InputSystemComponent self)
{
    Unit myUnit = self.GetMyUnit();
    if (myUnit == null) return;

    // 1. 先进行客户端预测移动（每帧）
    if (self.IsMoving)
    {
        MoveComponent moveComp = myUnit.GetComponent<MoveComponent>();
        if (moveComp != null && math.lengthsq(moveComp.JoystickDir) > 0.01f)
        {
            float speed = myUnit.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
            float dt = Time.deltaTime;
            myUnit.Position += moveComp.JoystickDir * speed * dt;
        }
    }

    // 2. 采集摇杆输入
    float2 joystickInput = self.GetJoystickInput();

    if (math.lengthsq(joystickInput) < 0.01f)
    {
        // 摇杆回中，发送停止
        if (self.IsMoving)
        {
            self.SendJoystickInput(float3.zero);
            self.IsMoving = false;
        }
        return;
    }

    // 归一化方向
    float3 moveDir = new float3(joystickInput.x, 0, joystickInput.y);
    moveDir = math.normalize(moveDir);

    // 更新移动方向（立即生效）
    MoveComponent moveComp2 = myUnit.GetComponent<MoveComponent>();
    if (moveComp2 != null)
    {
        moveComp2.JoystickDir = moveDir;
    }

    // 限制发送频率
    long now = TimeInfo.Instance.ClientNow();
    if (now - self.LastSendTime < SEND_INTERVAL_MS)
    {
        return;
    }

    self.SendJoystickInput(moveDir);
    self.LastSendTime = now;
    self.IsMoving = true;
}
```

2. 修改SendJoystickInput方法（移除位置更新）：
```csharp
public static void SendJoystickInput(this InputSystemComponent self, float3 dir)
{
    Unit myUnit = self.GetMyUnit();
    if (myUnit == null) return;

    // 1. 发送到服务端
    C2M_JoystickInput msg = C2M_JoystickInput.Create();
    msg.MoveDir = dir;
    msg.Seq = ++self.LastSendSeq;
    msg.ClientTime = TimeInfo.Instance.ClientNow();

    self.Scene().GetComponent<ClientSenderComponent>().Send(msg);

    // 2. 更新本地移动方向（不更新位置，位置在Update中每帧更新）
    MoveComponent moveComp = myUnit.GetComponent<MoveComponent>();
    if (moveComp == null)
    {
        moveComp = myUnit.AddComponent<MoveComponent>();
    }
    moveComp.JoystickDir = dir;

    // 3. 记录预测历史
    self.PredictionHistory.Add(new PredictionRecord
    {
        Seq = msg.Seq,
        Time = msg.ClientTime,
        Position = myUnit.Position,
        MoveDir = dir
    });

    // 保留最近1秒的历史
    self.CleanOldPredictions(1000);
}
```

---

## 2. 重要问题修复

### 问题2.1：BT每帧Tick性能问题

**原代码位置**：第5部分 - BTComponent系统

**问题**：每个Unit的BT每帧都Tick，性能开销大。

**修复方案**：

1. 在BTComponent中添加字段：
```csharp
[ComponentOf(typeof(Unit))]
public class BTComponent: Entity, IAwake<int>, IUpdate
{
    public int ConfigId;
    public BTNode RootNode;
    public BTContext Context;
    public BTStatus Status;

    // 新增字段
    public int BTTickInterval = 100;  // BT执行间隔（ms）
    public long LastBTTickTime;       // 上次执行时间
}
```

2. 修改Update方法：
```csharp
[EntitySystem]
private static void Update(this BTComponent self)
{
    if (self.RootNode == null)
        return;

    // 限制BT执行频率（10Hz）
    long now = TimeInfo.Instance.ServerNow();
    if (now - self.LastBTTickTime < self.BTTickInterval)
        return;

    self.LastBTTickTime = now;
    self.Status = self.RootNode.Tick(self.Context);
}
```

---

### 问题2.2：双武器BT同时运行冲突

**原代码位置**：第5部分 - InitWeaponBT方法

**问题**：两个武器的BT会同时运行，可能同时射击。

**修复方案**：

1. 修改WeaponComponent，添加当前武器字段：
```csharp
[ComponentOf(typeof(Unit))]
public class WeaponComponent: Entity, IAwake<int, int>
{
    public int RifleId;
    public int SMGId;
    public WeaponType CurrentWeapon = WeaponType.Rifle;  // ← 添加当前武器

    // ... 其他字段
}
```

2. 修改InitWeaponBT方法：
```csharp
public static void InitWeaponBT(this Unit self, int rifleId, int smgId)
{
    WeaponComponent weaponComp = self.GetComponent<WeaponComponent>();
    if (weaponComp == null)
    {
        weaponComp = self.AddComponent<WeaponComponent, int, int>(rifleId, smgId);
    }

    // 只添加当前装备武器的BT
    int currentWeaponId = weaponComp.CurrentWeapon == WeaponType.Rifle ? rifleId : smgId;
    self.AddChild<BTComponent, int>(currentWeaponId);
}
```

3. 添加切换武器方法：
```csharp
public static void SwitchWeapon(this Unit self, WeaponType weaponType)
{
    WeaponComponent weaponComp = self.GetComponent<WeaponComponent>();
    if (weaponComp == null)
        return;

    if (weaponComp.CurrentWeapon == weaponType)
        return;

    weaponComp.CurrentWeapon = weaponType;

    // 移除旧BT
    BTComponent oldBT = self.GetChild<BTComponent>();
    oldBT?.Dispose();

    // 添加新BT
    int weaponId = weaponType == WeaponType.Rifle ? weaponComp.RifleId : weaponComp.SMGId;
    self.AddChild<BTComponent, int>(weaponId);
}
```

---

### 问题2.3：目标选择频率优化

**原代码位置**：第4部分 - TargetSelectorComponent

**问题**：500ms选择一次目标，频率过高。

**修复方案**：

修改配置表默认值：
```csharp
// TargetSelectorConfig.xlsx
public class TargetSelectorConfig
{
    public int Id;
    public int SelectIntervalMs = 1000;  // ← 改为1000ms（1秒）
    public float MaxRange = 10.0f;
    public float DistanceWeight = 0.7f;
    public float HpWeight = 0.3f;
    public float AttackMeBonus = 0.5f;
}
```

---

## 3. 次要问题修复

### 问题3.1：摇杆UI获取实现

**原代码位置**：第2部分 - GetJoystickInput方法

**修复方案**：

根据项目使用YIUI框架，实现摇杆获取：
```csharp
private static float2 GetJoystickInput(this InputSystemComponent self)
{
    // 方案1：从YIUI获取（如果有摇杆组件）
    try
    {
        var root = self.Scene().Root();
        var yiuiComponent = root.GetComponent<YIUIComponent>();
        if (yiuiComponent != null)
        {
            // 假设摇杆在LobbyPanel中
            var lobbyPanel = yiuiComponent.GetPanel<LobbyPanelComponent>();
            if (lobbyPanel != null)
            {
                // 需要在LobbyPanel中添加摇杆引用
                // return new float2(lobbyPanel.Joystick.Horizontal, lobbyPanel.Joystick.Vertical);
            }
        }
    }
    catch (Exception e)
    {
        Log.Error($"GetJoystickInput error: {e}");
    }

    // 方案2：从Unity Input System获取（临时方案）
    #if UNITY_EDITOR || UNITY_STANDALONE
    float h = UnityEngine.Input.GetAxis("Horizontal");
    float v = UnityEngine.Input.GetAxis("Vertical");
    return new float2(h, v);
    #endif

    return float2.zero;
}
```

**注意**：需要在LobbyPanelComponent中添加摇杆组件引用。

---

### 问题3.2：协议字段类型修正

**原代码位置**：第2部分 - 协议定义

**问题**：protobuf不直接支持Unity.Mathematics.float3。

**修复方案**：

创建Vector3消息类型：
```protobuf
// Vector3.proto
message Vector3
{
    float x = 1;
    float y = 2;
    float z = 3;
}

// C2M_JoystickInput.proto
message C2M_JoystickInput // IMessage
{
    int32 RpcId = 1;
    int32 Seq = 2;
    Vector3 MoveDir = 3;  // ← 使用Vector3
    int64 ClientTime = 4;
}

// M2C_JoystickState.proto
message M2C_JoystickState // IMessage
{
    int32 RpcId = 1;
    int64 UnitId = 2;
    Vector3 Position = 3;  // ← 使用Vector3
    Vector3 MoveDir = 4;   // ← 使用Vector3
    bool IsMoving = 5;
    int32 Seq = 6;
}
```

在代码中转换：
```csharp
// 发送时
msg.MoveDir = new Vector3 { x = dir.x, y = dir.y, z = dir.z };

// 接收时
float3 moveDir = new float3(msg.MoveDir.x, msg.MoveDir.y, msg.MoveDir.z);
```

---

## 4. 枚举和常量定义

### 4.1 TimerInvokeType枚举

需要在TimerInvokeType中添加：
```csharp
public static class TimerInvokeType
{
    // ... 原有定义

    public const int JoystickMoveTimer = 1001;  // 摇杆移动Timer
    public const int JoystickSyncTimer = 1002;  // 摇杆同步Timer
}
```

### 4.2 NumericType枚举

确认以下枚举值存在：
```csharp
public static class NumericType
{
    // ... 原有定义

    public const int Speed = 1001;    // 移动速度
    public const int Hp = 1002;       // 当前血量
    public const int MaxHp = 1003;    // 最大血量
}
```

---

## 5. 配置表文件清单

需要创建以下Excel配置文件：

1. **JoystickMoveConfig.xlsx**
   - Id, ServerTickMs, SyncIntervalMs, MaxSpeed, InputTimeoutMs, NavMeshCheckDist

2. **CampConfig.xlsx**
   - Id, Name, Type, EnemyCamps

3. **TargetSelectorConfig.xlsx**
   - Id, SelectIntervalMs, MaxRange, DistanceWeight, HpWeight, AttackMeBonus

4. **WeaponConfig.xlsx**
   - Id, Name, Type, Damage, AttackRange, AttackInterval, MagazineSize, ReloadTime, CanMoveWhileFire, BTConfigId, ProjectilePrefab

5. **CameraConfig.xlsx**
   - Id, IsFixedTopDown, FixedPitch, FixedDistance, FixedHeight, FollowDamping, LookDamping

---

## 6. 实施检查清单

### 阶段1：代码修复
- [x] 修复同步Timer未保存问题
- [x] 添加MoveComponent字段初始化
- [x] 修复客户端预测逻辑
- [x] 优化BT执行频率
- [x] 解决双武器BT冲突
- [x] 优化目标选择频率
- [x] 修正协议字段类型

### 阶段2：补充实现
- [ ] 实现摇杆UI获取逻辑
- [ ] 添加TimerInvokeType枚举值
- [ ] 确认NumericType枚举值
- [ ] 创建所有配置表Excel文件

### 阶段3：兼容性测试
- [ ] 测试与现有MoveComponent的兼容性
- [ ] 测试Timer的创建和销毁
- [ ] 测试客户端预测效果
- [ ] 测试BT性能

---

## 7. 修改后的关键代码汇总

### 7.1 MoveComponent完整定义

```csharp
[ComponentOf(typeof(Unit))]
public class MoveComponent: Entity, IAwake, IDestroy
{
    // ===== 原有字段（路径移动） =====
    public List<float3> Targets = new List<float3>();
    public float3 StartPos;
    public long BeginTime;
    public long StartTime;
    public long NeedTime;
    public long MoveTimer;
    public float Speed;
    public int N;
    public int TurnTime;
    public bool IsTurnHorizontal;
    public quaternion From;
    public quaternion To;
    public ETTask<bool> tcs;

    // ===== 新增字段（摇杆移动） =====
    public MoveMode Mode;           // 移动模式
    public float3 JoystickDir;      // 摇杆方向（归一化）
    public int LastSeq;             // 最后接收的输入序列号
    public long LastInputTime;      // 最后接收输入的时间
    public float3 LastNavMeshPos;   // 上次NavMesh回贴位置
    public float SpeedScale;        // 速度缩放（用于超时减速）
    public float3 LastSyncPos;      // 上次同步位置
    public float3 LastSyncDir;      // 上次同步方向
    public long SyncTimer;          // 同步Timer（修复）
}
```

### 7.2 InputSystemComponent.Update完整实现

```csharp
[EntitySystem]
private static void Update(this InputSystemComponent self)
{
    Unit myUnit = self.GetMyUnit();
    if (myUnit == null) return;

    // 1. 客户端预测移动（每帧）
    if (self.IsMoving)
    {
        MoveComponent moveComp = myUnit.GetComponent<MoveComponent>();
        if (moveComp != null && math.lengthsq(moveComp.JoystickDir) > 0.01f)
        {
            float speed = myUnit.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
            float dt = Time.deltaTime;
            myUnit.Position += moveComp.JoystickDir * speed * dt;
        }
    }

    // 2. 采集摇杆输入
    float2 joystickInput = self.GetJoystickInput();

    if (math.lengthsq(joystickInput) < 0.01f)
    {
        if (self.IsMoving)
        {
            self.SendJoystickInput(float3.zero);
            self.IsMoving = false;
        }
        return;
    }

    // 3. 归一化方向并更新
    float3 moveDir = new float3(joystickInput.x, 0, joystickInput.y);
    moveDir = math.normalize(moveDir);

    MoveComponent moveComp2 = myUnit.GetComponent<MoveComponent>();
    if (moveComp2 != null)
    {
        moveComp2.JoystickDir = moveDir;
    }

    // 4. 限制发送频率
    long now = TimeInfo.Instance.ClientNow();
    if (now - self.LastSendTime < SEND_INTERVAL_MS)
    {
        return;
    }

    self.SendJoystickInput(moveDir);
    self.LastSendTime = now;
    self.IsMoving = true;
}
```

---

**文档版本**：v1.1
**修复日期**：2026-03-01
**状态**：已修复
