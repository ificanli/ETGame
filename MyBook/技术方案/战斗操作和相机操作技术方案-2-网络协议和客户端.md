# 战斗操作和相机操作技术方案 - 第2部分：网络协议和客户端实现

## 4. 网络协议设计

### 4.1 客户端上报输入协议

```protobuf
// C2M_JoystickInput.proto
message C2M_JoystickInput // IMessage
{
    int32 RpcId = 1;
    int32 Seq = 2;                          // 输入序列号
    Unity.Mathematics.float3 MoveDir = 3;   // 移动方向（归一化，长度为0表示停止）
    int64 ClientTime = 4;                   // 客户端时间戳
}
```

### 4.2 服务端广播状态协议

```protobuf
// M2C_JoystickState.proto
message M2C_JoystickState // IMessage
{
    int32 RpcId = 1;
    int64 UnitId = 2;                       // Unit ID
    Unity.Mathematics.float3 Position = 3;  // 当前位置
    Unity.Mathematics.float3 MoveDir = 4;   // 移动方向
    bool IsMoving = 5;                      // 是否移动中
    int32 Seq = 6;                          // 对应的输入序列号（仅自己单位有效）
}
```

### 4.3 手动切换目标协议

```protobuf
// C2M_SwitchTarget.proto
message C2M_SwitchTarget // IMessage
{
    int32 RpcId = 1;
    int64 TargetId = 2;     // 目标ID（0表示取消目标）
}

// M2C_SwitchTarget.proto
message M2C_SwitchTarget // IMessage
{
    int32 RpcId = 1;
    int32 Error = 2;
    int64 TargetId = 3;
}
```

---

## 5. 客户端实现

### 5.1 InputSystemComponent

```csharp
[ComponentOf(typeof(Scene))]
public class InputSystemComponent: Entity, IAwake, IUpdate
{
    public long LastSendTime;
    public int LastSendSeq;
    public bool IsMoving;
    public List<PredictionRecord> PredictionHistory = new List<PredictionRecord>();
}

public class PredictionRecord
{
    public int Seq;
    public long Time;
    public float3 Position;
    public float3 MoveDir;
}
```

### 5.2 输入采集和发送

```csharp
[EntitySystem]
public static partial class InputSystemComponentSystem
{
    private const int SEND_INTERVAL_MS = 50;  // 20Hz发送频率

    [EntitySystem]
    private static void Awake(this InputSystemComponent self)
    {
        self.LastSendTime = 0;
        self.LastSendSeq = 0;
        self.IsMoving = false;
        self.PredictionHistory.Clear();
    }

    [EntitySystem]
    private static void Update(this InputSystemComponent self)
    {
        Unit myUnit = self.GetMyUnit();
        if (myUnit == null) return;

        // 1. 客户端预测移动（每帧）
        if (self.IsMoving)
        {
            MoveComponent moveComp = myUnit.GetComponent<MoveComponent>();
            if (moveComp != null && math.lengthsq(moveComp.JoystickDir) > 0.01f)
            {
                float speed = myUnit.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
                float dt = Time.deltaTime;
                myUnit.Position += moveComp.JoystickDir * speed * dt;
            }
        }

        // 2. 采集摇杆输入
        float2 joystickInput = self.GetJoystickInput();

        if (math.lengthsq(joystickInput) < 0.01f)
        {
            // 摇杆回中，发送停止
            if (self.IsMoving)
            {
                self.SendJoystickInput(float3.zero);
                self.IsMoving = false;
            }
            return;
        }

        // 归一化方向
        float3 moveDir = new float3(joystickInput.x, 0, joystickInput.y);
        moveDir = math.normalize(moveDir);

        // 更新本地移动方向（立即生效）
        MoveComponent moveComp2 = myUnit.GetComponent<MoveComponent>();
        if (moveComp2 != null)
        {
            moveComp2.JoystickDir = moveDir;
        }

        // 限制发送频率
        long now = TimeInfo.Instance.ClientNow();
        if (now - self.LastSendTime < SEND_INTERVAL_MS)
        {
            return;
        }

        self.SendJoystickInput(moveDir);
        self.LastSendTime = now;
        self.IsMoving = true;
    }

    // 获取摇杆输入（从UI获取）
    private static float2 GetJoystickInput(this InputSystemComponent self)
    {
        // TODO: 从UI摇杆组件获取输入
        // 示例：
        // var joystick = self.Scene().GetComponent<UIComponent>().GetJoystick();
        // return new float2(joystick.Horizontal, joystick.Vertical);
        return float2.zero;
    }

    // 获取我的Unit
    private static Unit GetMyUnit(this InputSystemComponent self)
    {
        Player player = self.Scene().GetComponent<PlayerComponent>().MyPlayer;
        if (player == null)
            return null;

        return player.GetComponent<UnitComponent>().MyUnit;
    }
}
```

### 5.3 客户端预测

```csharp
public static void SendJoystickInput(this InputSystemComponent self, float3 dir)
{
    Unit myUnit = self.GetMyUnit();
    if (myUnit == null) return;

    // 1. 发送到服务端
    C2M_JoystickInput msg = C2M_JoystickInput.Create();
    msg.MoveDir = dir;
    msg.Seq = ++self.LastSendSeq;
    msg.ClientTime = TimeInfo.Instance.ClientNow();

    self.Scene().GetComponent<ClientSenderComponent>().Send(msg);

    // 2. 更新本地移动方向（位置在Update中每帧更新）
    MoveComponent moveComp = myUnit.GetComponent<MoveComponent>();
    if (moveComp == null)
    {
        moveComp = myUnit.AddComponent<MoveComponent>();
    }
    moveComp.JoystickDir = dir;

    // 3. 记录预测历史（用于服务端回正）
    self.PredictionHistory.Add(new PredictionRecord
    {
        Seq = msg.Seq,
        Time = msg.ClientTime,
        Position = myUnit.Position,
        MoveDir = dir
    });

    // 保留最近1秒的历史
    self.CleanOldPredictions(1000);
}

// 清理旧的预测记录
public static void CleanOldPredictions(this InputSystemComponent self, long keepTimeMs)
{
    long now = TimeInfo.Instance.ClientNow();
    self.PredictionHistory.RemoveAll(p => now - p.Time > keepTimeMs);
}

// 查找预测记录
public static PredictionRecord FindPrediction(this InputSystemComponent self, int seq)
{
    return self.PredictionHistory.Find(p => p.Seq == seq);
}

// 移除指定Seq之前的预测
public static void RemovePredictionsBefore(this InputSystemComponent self, int seq)
{
    self.PredictionHistory.RemoveAll(p => p.Seq <= seq);
}
```

### 5.4 服务端状态回正

```csharp
[MessageHandler(SceneType.Client)]
public class M2C_JoystickStateHandler : MessageHandler<Unit, M2C_JoystickState>
{
    protected override async ETTask Run(Unit unit, M2C_JoystickState message)
    {
        unit.OnJoystickState(message);
        await ETTask.CompletedTask;
    }
}

public static void OnJoystickState(this Unit self, M2C_JoystickState msg)
{
    if (self.IsMyUnit())
    {
        // 自己的单位：需要回正
        InputSystemComponent inputComp = self.Scene().GetComponent<InputSystemComponent>();

        // 查找对应Seq的预测记录
        PredictionRecord record = inputComp.FindPrediction(msg.Seq);
        if (record != null)
        {
            // 计算预测误差
            float error = math.distance(record.Position, msg.Position);

            if (error > 0.5f)
            {
                // 误差过大（>0.5米），硬对齐
                self.Position = msg.Position;
                Log.Warning($"Large prediction error: {error}m, hard snap");
            }
            else if (error > 0.1f)
            {
                // 小误差（0.1-0.5米），平滑回正
                self.Position = math.lerp(self.Position, msg.Position, 0.3f);
            }
            // 误差很小（<0.1米），忽略（信任客户端预测）

            // 清理已确认的预测
            inputComp.RemovePredictionsBefore(msg.Seq);
        }
        else
        {
            // 找不到对应记录，直接使用服务端位置
            self.Position = msg.Position;
        }
    }
    else
    {
        // 其他玩家：直接插值
        self.Position = msg.Position;

        MoveComponent moveComp = self.GetComponent<MoveComponent>();
        if (moveComp != null)
        {
            moveComp.JoystickDir = msg.MoveDir;
        }
    }
}

// 判断是否是自己的Unit
public static bool IsMyUnit(this Unit self)
{
    Scene scene = self.Scene();
    Player myPlayer = scene.GetComponent<PlayerComponent>().MyPlayer;
    if (myPlayer == null)
        return false;

    Unit myUnit = myPlayer.GetComponent<UnitComponent>().MyUnit;
    return myUnit != null && myUnit.Id == self.Id;
}
```

### 5.5 客户端移动表现

```csharp
// 客户端每帧更新Unit位置（用于平滑移动）
[EntitySystem]
public static void ClientMoveUpdate(this Unit self)
{
    MoveComponent moveComp = self.GetComponent<MoveComponent>();
    if (moveComp == null || moveComp.Mode != MoveMode.Joystick)
        return;

    // 如果不是自己的Unit，需要插值移动
    if (!self.IsMyUnit())
    {
        if (math.lengthsq(moveComp.JoystickDir) > 0.01f)
        {
            float speed = self.GetComponent<NumericComponent>().GetAsFloat(NumericType.Speed);
            float dt = Time.deltaTime;
            float3 newPos = self.Position + moveComp.JoystickDir * speed * dt;
            self.Position = newPos;
        }
    }
}
```

---

## 6. 手动切换目标

### 6.1 客户端发送切换请求

```csharp
public static void SwitchTarget(this InputSystemComponent self, long targetId)
{
    C2M_SwitchTarget msg = C2M_SwitchTarget.Create();
    msg.TargetId = targetId;

    self.Scene().GetComponent<ClientSenderComponent>().Send(msg);
}
```

### 6.2 服务端处理切换请求

```csharp
[MessageHandler(SceneType.Map)]
public class C2M_SwitchTargetHandler : MessageHandler<Unit, C2M_SwitchTarget, M2C_SwitchTarget>
{
    protected override async ETTask Run(Unit unit, C2M_SwitchTarget request, M2C_SwitchTarget response)
    {
        TargetSelectorComponent selector = unit.GetComponent<TargetSelectorComponent>();
        if (selector == null)
        {
            response.Error = ErrorCode.ERR_ComponentNotFound;
            return;
        }

        // 验证目标是否有效
        if (request.TargetId != 0)
        {
            Unit target = unit.Scene().GetComponent<UnitComponent>().Get(request.TargetId);
            if (target == null)
            {
                response.Error = ErrorCode.ERR_TargetNotFound;
                return;
            }

            // 检查是否敌对
            if (!CampHelper.IsEnemy(unit, target))
            {
                response.Error = ErrorCode.ERR_TargetNotEnemy;
                return;
            }
        }

        // 设置手动目标
        selector.SetManualTarget(request.TargetId);

        response.Error = ErrorCode.ERR_Success;
        response.TargetId = request.TargetId;

        await ETTask.CompletedTask;
    }
}
```

---
