# 9.5 范围内自动普攻改造方案

## 1. 需求概述

将当前项目的攻击触发逻辑改造为：范围内有目标时自动触发普攻。

目标行为：
- 玩家进入战斗状态后，自动检测攻击范围内的敌对目标
- 有目标时自动施放普攻技能
- 无需玩家手动点击或操作即可持续攻击

---

## 2. 现有系统分析

### 2.1 目标管理

当前目标系统：`Packages/cn.etetet.spell/Scripts/Model/Share/TargetComponent.cs`

```csharp
[ComponentOf(typeof(Unit))]
public class TargetComponent: Entity, IAwake
{
    public Unit Unit { get; set; }      // 当前锁定目标
    public float3 Position { get; set; } // 目标位置
}
```

### 2.2 技能系统

技能施放入口：`Packages/cn.etetet.spell/Scripts/Hotfix/Server/SpellHelper.cs`

- `SpellHelper.Cast(unit, spellConfigId)` - 无目标施放
- `SpellHelper.Cast(unit, spellConfigId, target)` - 指定目标施放

### 2.3 AI追击参考

怪物追击逻辑：`Packages/cn.etetet.btnode/Scripts/Hotfix/Server/AI/AI_MonsterZhuiJiHandler.cs`

核心流程：
1. 从 `ThreatComponent` 获取仇恨最高目标
2. 计算与目标距离
3. 距离过远则寻路靠近
4. 距离合适则施放技能

### 2.4 AOI 系统

AOI 管理：`Packages/cn.etetet.aoi/Scripts/Hotfix/Server/AOIHelper.cs`

- 基于格子的视野管理
- 可获取周围单位列表

---

## 3. 改造方案

### 3.1 新增组件

#### AutoAttackComponent（自动攻击组件）

位置：`Packages/cn.etetet.spell/Scripts/Model/Share/AutoAttackComponent.cs`

```csharp
[ComponentOf(typeof(Unit))]
public class AutoAttackComponent : Entity, IAwake
{
    // 是否启用自动攻击
    public bool Enabled { get; set; }

    // 普攻技能ID（配置化）
    public int NormalAttackSpellId { get; set; }

    // 攻击检测范围（米）
    public float DetectRange { get; set; }

    // 攻击间隔（毫秒）
    public long AttackInterval { get; set; }

    // 上次攻击时间
    public long LastAttackTime { get; set; }

    // 当前自动攻击目标
    private EntityRef<Unit> target;
    public Unit Target
    {
        get => target;
        set => target = value;
    }
}
```

### 3.2 新增 System

#### AutoAttackComponentSystem

位置：`Packages/cn.etetet.spell/Scripts/Hotfix/Server/AutoAttackComponentSystem.cs`

核心逻辑：

```csharp
[EntitySystemOf(typeof(AutoAttackComponent))]
[FriendOf(typeof(AutoAttackComponent))]
public static partial class AutoAttackComponentSystem
{
    [EntitySystem]
    private static void Awake(this AutoAttackComponent self)
    {
        self.Enabled = false;
        self.NormalAttackSpellId = 100100; // 默认普攻ID，应配置化
        self.DetectRange = 5f;              // 默认5米
        self.AttackInterval = 1000;         // 默认1秒
    }

    /// <summary>
    /// 开启自动攻击
    /// </summary>
    public static void Enable(this AutoAttackComponent self)
    {
        self.Enabled = true;
        self.StartAutoAttackLoop().Coroutine();
    }

    /// <summary>
    /// 关闭自动攻击
    /// </summary>
    public static void Disable(this AutoAttackComponent self)
    {
        self.Enabled = false;
        self.Target = null;
    }

    /// <summary>
    /// 自动攻击主循环
    /// </summary>
    private static async ETTask StartAutoAttackLoop(this AutoAttackComponent self)
    {
        Unit unit = self.GetParent<Unit>();
        EntityRef<Unit> unitRef = unit;
        TimerComponent timerComponent = unit.Root().TimerComponent;

        while (self.Enabled && !self.IsDisposed)
        {
            await timerComponent.WaitAsync(200); // 每200ms检测一次

            unit = unitRef;
            if (unit == null || unit.IsDisposed)
            {
                break;
            }

            // 1. 寻找范围内目标
            Unit target = self.FindTargetInRange(unit);
            if (target == null)
            {
                self.Target = null;
                continue;
            }

            self.Target = target;

            // 2. 检查攻击间隔
            long now = TimeInfo.Instance.ServerNow();
            if (now - self.LastAttackTime < self.AttackInterval)
            {
                continue;
            }

            // 3. 施放普攻
            int ret = SpellHelper.Cast(unit, self.NormalAttackSpellId, target);
            if (ret == 0)
            {
                self.LastAttackTime = now;
            }
        }
    }

    /// <summary>
    /// 在攻击范围内寻找目标
    /// </summary>
    private static Unit FindTargetInRange(this AutoAttackComponent self, Unit unit)
    {
        // 方案1：优先使用 ThreatComponent（如果有仇恨系统）
        ThreatComponent threatComponent = unit.GetComponent<ThreatComponent>();
        if (threatComponent != null)
        {
            ThreatInfo threatInfo = threatComponent.GetMaxThreat();
            if (threatInfo?.Unit != null)
            {
                float distance = math.distance(unit.Position, threatInfo.Unit.Position);
                if (distance <= self.DetectRange)
                {
                    return threatInfo.Unit;
                }
            }
        }

        // 方案2：使用 AOI 系统查找范围内敌对单位
        AOIEntity aoiEntity = unit.GetComponent<AOIEntity>();
        if (aoiEntity == null)
        {
            return null;
        }

        Unit nearestTarget = null;
        float nearestDistance = float.MaxValue;

        foreach (var kv in aoiEntity.SeeUnits)
        {
            Unit seeUnit = kv.Value;
            if (seeUnit == null || seeUnit.IsDisposed)
            {
                continue;
            }

            // 过滤：只攻击敌对单位
            if (!IsHostile(unit, seeUnit))
            {
                continue;
            }

            float distance = math.distance(unit.Position, seeUnit.Position);
            if (distance <= self.DetectRange && distance < nearestDistance)
            {
                nearestTarget = seeUnit;
                nearestDistance = distance;
            }
        }

        return nearestTarget;
    }

    /// <summary>
    /// 判断是否为敌对单位
    /// </summary>
    private static bool IsHostile(Unit self, Unit other)
    {
        // 根据项目实际阵营系统实现
        // 示例：玩家攻击怪物
        if (self.UnitType == UnitType.Player && other.UnitType == UnitType.Monster)
        {
            return true;
        }
        // 可扩展：阵营判断、PVP判断等
        return false;
    }
}
```

### 3.3 配置化设计

#### 新增配置表：AutoAttackConfig

| 字段 | 类型 | 说明 |
|------|------|------|
| Id | int | 配置ID |
| NormalAttackSpellId | int | 普攻技能ID |
| DetectRange | float | 检测范围（米） |
| AttackInterval | int | 攻击间隔（毫秒） |
| Priority | int | 目标选择优先级规则 |

---

## 4. 触发时机

### 4.1 何时开启自动攻击

建议触发点：

1. **进入战斗状态时**
   - 被攻击时
   - 主动攻击时
   - 进入战斗区域时

2. **客户端请求开启**
   - 玩家点击"自动战斗"按钮
   - 发送 `C2M_EnableAutoAttack` 消息

### 4.2 何时关闭自动攻击

1. 玩家死亡
2. 离开战斗状态（脱战）
3. 客户端请求关闭
4. 切换场景

---

## 5. 协议设计

### 5.1 客户端请求

```protobuf
// 开启/关闭自动攻击
message C2M_SetAutoAttack // ILocationMessage
{
    bool Enable = 1;
}

message M2C_SetAutoAttack // IMessage
{
    bool Enable = 1;
}
```

### 5.2 状态同步

```protobuf
// 自动攻击目标变更通知
message M2C_AutoAttackTargetChanged // IMessage
{
    int64 TargetId = 1;
}
```

---

## 6. 实施步骤

### Phase 1：基础功能

1. 创建 `AutoAttackComponent` 组件
2. 实现 `AutoAttackComponentSystem` 核心逻辑
3. 在 `UnitFactory` 中为玩家挂载组件

### Phase 2：协议与客户端

1. 添加协议定义
2. 实现 Handler
3. 客户端 UI 添加自动攻击开关

### Phase 3：配置化与优化

1. 添加配置表
2. 目标选择策略优化（最近/最低血量/仇恨最高）
3. 性能优化（检测频率动态调整）

---

## 7. 关键文件清单

| 操作 | 文件路径 |
|------|----------|
| 新增 | `Packages/cn.etetet.spell/Scripts/Model/Share/AutoAttackComponent.cs` |
| 新增 | `Packages/cn.etetet.spell/Scripts/Hotfix/Server/AutoAttackComponentSystem.cs` |
| 修改 | `Packages/cn.etetet.map/Scripts/Hotfix/Server/UnitFactory.cs` |
| 新增 | `Packages/cn.etetet.spell/Proto/Spell_C_10200.proto`（追加协议） |
| 新增 | `Luban/Config/Share/AutoAttackConfig.xlsx`（可选） |

---

## 8. 注意事项

1. **EntityRef 安全**：循环中 await 后必须重新获取 Unit 引用
2. **性能考虑**：检测频率不宜过高，200ms 一次较为合理
3. **服务端权威**：自动攻击逻辑在服务端执行，客户端仅展示
4. **配置化**：普攻技能ID、检测范围、攻击间隔都应配置化
5. **阵营系统**：`IsHostile` 需根据项目实际阵营系统实现
