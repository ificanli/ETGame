# 地图系统说明

## 1. 系统概览

地图系统由两个包组成：

| 包名 | 层级 | 职责 |
|------|------|------|
| `cn.etetet.map` | 第5层 | 地图核心逻辑：单位管理、AOI、寻路、传送、客户端场景切换 |
| `cn.etetet.mapmanager` | — | 地图副本管理：分配副本、分线、合线、生命周期 |

`cn.etetet.map` 依赖 `cn.etetet.actorlocation`（Location消息系统），并设置了 `AllowSameLevelAccess`。

### 架构关系

```
MapManager (Fiber)          Map (Fiber, 每个副本一个)
┌──────────────────┐       ┌──────────────────────────┐
│ MapManagerComponent│──创建──▶│ UnitComponent            │
│   ├─ MapInfo(Map1) │       │ AOIManagerComponent      │
│   │  ├─ MapCopy(1) │       │ NavmeshComponent(寻路)   │
│   │  └─ MapCopy(2) │       │ LocationProxy/MessageSender│
│   └─ MapInfo(Map2) │       └──────────────────────────┘
│ MergeLinesComponent│
└──────────────────┘
```

---

## 2. 配置表说明

配置表 Excel 位于 `Packages/cn.etetet.map/Luban/Config/Datas/`。

### MapConfig（Map.xlsx）

| 字段 | 类型 | 说明 |
|------|------|------|
| Id | int | 地图ID |
| Name | string | 地图名称（如 "Map1"、"Lordaeron"） |
| Desc | string | 描述 |
| CopyType | CopyType | 副本类型：Normal=1 / Line=2 / Copy=3 |
| MaxLineNum | int | 最大分线数（仅Line类型有效） |
| MaxPlayerNum | int | 单个副本最大玩家数 |
| RecommendPlayerNum | int | 推荐玩家数，超过此值开新线/副本 |
| MapResName | string | 场景资源名（用于加载Unity场景） |

扩展方法 `GetByName(string mapName)` 支持按名称查找地图配置。

### MapUnitConfig（MapUnit.xlsx）

| 字段 | 类型 | 说明 |
|------|------|------|
| Id | int | 地图单位实例ID（同时作为Unit的Id） |
| UnitConfigId | int | 引用 UnitConfig 的ID |
| MapName | string | 所属地图名称 |
| KV | Dict<int,long> | 数值属性覆盖（位置X/Y/Z、Yaw朝向等） |

地图初始化时，会根据 MapName 筛选出该地图的所有 MapUnitConfig，逐个创建 Unit。

### MapTransferRuleConfig（MapTransferRule.xlsx）

| 字段 | 类型 | 说明 |
|------|------|------|
| Id | int | 传送规则ID |
| ToMap | string | 目标地图名称 |
| Pos | float[] | 目标位置坐标 |

客户端发起 `C2M_TransferMap` 时携带传送规则ID，服务端据此查找目标地图和落点。

---

## 3. 地图类型（CopyType）

```csharp
public enum CopyType
{
    Normal = 1,  // 普通地图
    Line = 2,    // 分线地图
    Copy = 3,    // 副本
}
```

| 类型 | 说明 | 副本ID生成 | 典型场景 |
|------|------|-----------|---------|
| Normal | 全服唯一实例 | IdGenerater随机ID | 主城、野外 |
| Line | 多线并行，支持合线 | 顺序编号(1,2,3...) | 高人数野外地图 |
| Copy | 每组独立副本 | IdGenerater随机ID | 副本、战场 |

**Line 分线逻辑**：当某条线玩家数超过 `RecommendPlayerNum` 时自动开新线；`MergeLinesComponent` 定时检测低人数线并合并。

---

## 4. 服务端地图初始化流程（FiberInit_Map）

文件：`Packages/cn.etetet.map/Scripts/Hotfix/Server/FiberInit_Map.cs`

Map Fiber 创建时执行以下初始化：

```
1. 添加基础组件
   ├─ MailBoxComponent (UnOrderedMessage)
   ├─ TimerComponent
   ├─ CoroutineLockComponent
   ├─ ProcessInnerSender
   ├─ MessageSender
   ├─ LocationProxyComponent
   └─ MessageLocationSenderComponent

2. 添加地图核心组件
   ├─ UnitComponent          ← 管理所有Unit
   └─ AOIManagerComponent    ← AOI视野管理（50米格子）

3. 加载寻路数据（非GateMap时）
   └─ NavmeshComponent.Instance.Load(sceneName)
      → 读取 Bundles/Recast/{sceneName}.bytes

4. 生成地图单位
   └─ 遍历 MapUnitConfigCategory 中 MapName 匹配的配置
      → UnitFactory.Create(scene, mapUnitConfig.Id, mapUnitConfig.UnitConfigId)

5. 注册服务发现
   ├─ ServiceDiscoveryProxy.RegisterService()
   └─ ServiceDiscoveryProxy.Subscribe(Location, MapManager)
```

### UnitFactory.Create 详细流程

```csharp
Unit unit = unitComponent.AddChildWithId<Unit, int>(id, configId);
// 1. 设置 UnitType
// 2. 添加 NumericComponent，写入 UnitConfig.KV
// 3. 非玩家单位：覆盖写入 MapUnitConfig.KV（位置、朝向等）
// 4. 从 Numeric 读取 X/Y/Z 设置 Position，读取 Yaw 设置 Rotation
// 5. 添加组件：MoveComponent, TurnComponent, AOIEntity, TargetComponent, SpellComponent, BuffComponent
// 6. 玩家额外：ItemComponent, QuestComponent
// 7. 怪物额外：ThreatComponent, PathfindingComponent(加载寻路)
// 8. 如果配置了 AI 数值，通过 BuffHelper 创建 AI Buff
```

---

## 5. MapManager 副本管理

文件：`Packages/cn.etetet.mapmanager/Scripts/Hotfix/Server/`

### 初始化（FiberInit_MapManager）

MapManager 是独立 Fiber，初始化组件与 Map 类似，核心是 `MapManagerComponent`。

### 数据结构

```
MapManagerComponent
├─ MapInfos: Dictionary<string, MapInfo>    ← 按地图名索引
│
MapInfo (每种地图一个)
├─ MapName: string
├─ Children: MapCopy[]                      ← 该地图的所有副本
│
MapCopy (每个副本实例)
├─ FiberId: int                             ← 对应的Map Fiber
├─ Players: HashSet<long>                   ← 已进入的玩家
├─ WaitEnterPlayer: Dictionary<long, long>  ← 等待进入的玩家(UnitId→时间戳)
├─ Status: MapCopyStatus                    ← Running/WaitFinish/Finished/WaitMerge
└─ MergeTime: long
```

### 副本分配流程（GetMapAsync）

```
收到 A2MapManager_GetMapRequest(MapName, MapId, UnitId)
│
├─ 查找 MapInfo，不存在则创建
├─ 根据 CopyType 分配副本：
│   ├─ Normal: 查找已有Running副本，无则创建（ID=IdGenerater随机）
│   ├─ Line:   查找人数 < RecommendPlayerNum 的线，无则开新线（ID=顺序编号）
│   └─ Copy:   直接创建新副本（ID=IdGenerater随机）
├─ 创建副本时：新建 Map Fiber → 记录 FiberId
├─ mapCopy.AddWaitPlayer(unitId)  ← 加入等待列表
└─ 返回 MapActorId（目标Map Fiber的地址）
```

### 玩家确认进入（NotifyPlayerAlreadyEnterMap）

```
收到 A2MapManager_NotifyPlayerAlreadyEnterMapRequest
├─ mapCopy.AddPlayer(unitId)      ← 从等待列表移到正式列表
└─ preMapCopy.Players.Remove(unitId)  ← 从旧副本移除
```

### 分线合并（MergeLinesComponent）

仅 Line 类型地图启用。定时检测各线玩家数，当某线人数过低时标记 `WaitMerge`，将玩家传送到其他线后关闭该线。

---

## 6. 玩家进入地图流程

### 完整链路

```
客户端                        Gate服务器                    MapManager              Map服务器
  │                             │                            │                       │
  ├─ C2G_EnterMap ─────────────▶│                            │                       │
  │                             ├─ 获取Player                │                       │
  │                             ├─ 创建GateMapComponent      │                       │
  │                             ├─ 创建GateMap Fiber         │                       │
  │                             ├─ UnitFactory.Create(玩家)  │                       │
  │                             ├─ 添加UnitGateInfoComponent │                       │
  │◀─ G2C_EnterMap(MyId) ──────┤                            │                       │
  │                             ├─ TransferAtFrameFinish ────┼──────────────────────▶│
  │                             │  (等帧结束后执行传送)       │                       │
  │                             │                            │                       │
  │                      TransferHelper.Transfer:            │                       │
  │                             ├─ A2MapManager_GetMapReq ──▶│                       │
  │                             │                            ├─ 分配副本              │
  │                             │◀─ GetMapResp(MapActorId) ──┤                       │
  │                             │                            │                       │
  │                             ├─ Location锁定              │                       │
  │                             ├─ 移除AOIEntity             │                       │
  │                             ├─ 序列化Unit+ITransfer组件  │                       │
  │                             ├─ M2M_UnitTransferReq ─────────────────────────────▶│
  │                             │                            │                       ├─ 反序列化Unit
  │                             │                            │                       ├─ 重建组件
  │◀─ M2C_StartSceneChange ────┼────────────────────────────┼───────────────────────┤
  │◀─ M2C_CreateMyUnit ────────┼────────────────────────────┼───────────────────────┤
  │                             │                            │                       ├─ 添加AOIEntity
  │                             │◀─ UnitTransferResp(NewActorId) ───────────────────┤
  │                             ├─ Location解锁(新ActorId)   │                       │
  │                             ├─ NotifyPlayerAlreadyEnter ▶│                       │
  │                             │                            ├─ 更新玩家列表         │
```

### 客户端场景切换流程

```
收到 M2C_StartSceneChange(SceneId, SceneName)
│
├─ SceneChangeHelper.SceneChangeTo()
│   ├─ 判断是否需要切换场景（TransferSceneHelper.IsChangeScene）
│   ├─ 如需切换：
│   │   ├─ 销毁旧 CurrentScene
│   │   ├─ CurrentSceneFactory.Create() → 新场景
│   │   ├─ 添加 UnitComponent
│   │   └─ WaitUnitCreateFinish() → 等待 M2C_CreateMyUnit
│   │       ├─ 收到后 UnitFactory.Create(客户端) → 创建自己的Unit
│   │       ├─ 添加 TargetComponent, SpellComponent
│   │       └─ 发布 AfterMyUnitCreate 事件
│   │
│   ├─ 发布 SceneChangeStart 事件
│   │   └─ View层订阅：打开Loading界面，加载Unity场景资源
│   │
│   ├─ 加载寻路数据 NavmeshComponent.Instance.Load()
│   │
│   ├─ 发布 SceneChangeFinish 事件
│   │   └─ View层订阅：打开主界面、HUD
│   │
│   └─ Notify(Wait_SceneChangeFinish)
│
└─ EnterMapHelper 收到通知 → 发布 EnterMapFinish 事件
```

---

## 7. 地图传送流程

文件：`Packages/cn.etetet.map/Scripts/Hotfix/Server/TransferHelper.cs`

### 传送触发

客户端发送 `C2M_TransferMap`（携带传送规则ID），服务端查 `MapTransferRuleConfig` 获取目标地图和坐标。

### TransferHelper 核心流程

```
TransferAtFrameFinish(player, unit, mapName, mapId)
│
├─ 等待帧结束（避免在帧中间传送导致状态不一致）
│
└─ Transfer(unit, mapName, mapId)
    │
    ├─ 1. 请求MapManager分配副本
    │   └─ A2MapManager_GetMapRequest → 获得 MapActorId
    │
    ├─ 2. Location锁定（CoroutineLock）
    │   └─ 防止传送期间收到其他消息
    │
    ├─ 3. 移除AOIEntity
    │   └─ 从当前地图AOI中移除，触发 LeaveSight 通知周围玩家
    │
    ├─ 4. 序列化传送数据
    │   ├─ 同进程：直接传递Unit对象引用
    │   └─ 跨进程：BSON序列化 Unit + 所有ITransfer标记的组件
    │
    ├─ 5. 发送 M2M_UnitTransferRequest 到目标Map
    │   └─ 目标Map处理：
    │       ├─ 反序列化/接收Unit
    │       ├─ 重建 TurnComponent, MoveComponent, PathfindingComponent, MailBoxComponent, TargetComponent
    │       ├─ 通知客户端 M2C_StartSceneChange
    │       ├─ 通知客户端 M2C_CreateMyUnit（如果切换场景）
    │       └─ 添加 AOIEntity → 触发 EnterSight 通知新地图周围玩家
    │
    ├─ 6. Location解锁，更新为新ActorId
    │
    └─ 7. 通知MapManager玩家已进入
        └─ A2MapManager_NotifyPlayerAlreadyEnterMapRequest
```

### ITransfer 标记

组件实现 `ITransfer` 接口的会在传送时被序列化带走（如背包、任务等持久数据），未标记的组件在目标地图重新创建。

---

## 8. AOI 视野系统

AOI 包：`cn.etetet.aoi`（第4层，依赖 unit、numeric）

### 核心参数

```csharp
AOIManagerComponent.CellSize = 50 * 1000;  // 50米（单位：毫米）
```

### 数据结构

```
AOIManagerComponent (挂在Map Scene上)
├─ Cells: Dictionary<long, Cell>     ← 按格子坐标索引

Cell (每个50m×50m格子)
├─ AOIUnits: 当前在此格子的AOIEntity
├─ SubsEnterEntities: 订阅了此格子"进入"事件的AOIEntity
└─ SubsLeaveEntities: 订阅了此格子"离开"事件的AOIEntity

AOIEntity (挂在Unit上)
├─ Cell: 当前所在格子
├─ SeeUnits: 我能看到的单位
├─ BeSeeUnits: 能看到我的单位
├─ SeePlayers: 我能看到的玩家
├─ BeSeePlayers: 能看到我的玩家
├─ SubEnterCells: 我订阅的进入格子集合
├─ SubLeaveCells: 我订阅的离开格子集合
└─ Phase: PhaseType (相位，用于副本内分组可见性)
```

### 工作流程

```
1. Unit创建 → 添加AOIEntity → AOIManagerComponent.Add()
   ├─ 计算所在Cell坐标
   ├─ 订阅周围9宫格的Enter/Leave事件
   └─ 通知已在范围内的单位：触发 EnterSight

2. Unit移动 → Position变化 → ChangePosition事件 → AOIManagerComponent.Move()
   ├─ 如果跨Cell：更新订阅的格子集合
   ├─ 新进入的格子：触发 EnterSight
   └─ 离开的格子：触发 LeaveSight

3. EnterSight → UnitEnterSightRange_NotifyClient
   └─ 向玩家A发送 M2C_CreateUnits（包含B的UnitInfo）

4. LeaveSight → UnitLeaveSightRange_NotifyClient
   └─ 向玩家A发送 M2C_RemoveUnits（包含B的UnitId）
```

### PhaseType（相位系统）

```csharp
[Flags]
public enum PhaseType: long
{
    Normal = 1,
    Phase1 = 2,
    Phase2 = 4,
}
```

两个单位只有在相位有交集时才能互相看见（`SamePhase` 检查按位与）。

---

## 9. 寻路系统

寻路包：`cn.etetet.recast`，使用 DotRecast（C# 版 Recast/Detour）。

### 寻路数据

位置：`Packages/cn.etetet.map/Bundles/Recast/`

```
├── Lordaeron.bytes
├── Map1.bytes
└── Map2.bytes
```

这些是 C++ Recast 导出的二进制 NavMesh 数据。

### 加载流程

```
NavmeshComponent.Instance.Load(sceneName)
├─ 服务端：File.ReadAllBytes("Packages/cn.etetet.map/Bundles/Recast/{name}.bytes")
├─ 客户端：通过资源管理系统加载
└─ DtMeshSetReader.Read() → DtNavMesh
```

### PathfindingComponent

挂在怪物 Unit 上（玩家寻路由客户端发起）。

```csharp
[ComponentOf(typeof(Unit))]
public class PathfindingComponent: Entity, IAwake<string>, IDestroy
{
    public DtNavMesh navMesh;
    public DtNavMeshQuery query;
    // ...
}
```

关键方法：
- `Find(start, end, path)` — A*寻路，返回路径点列表
- `FindRandomPointAroundCircle(center, radius)` — 圆形范围内随机点
- `FindRandomPointWithRaduis(center, minR, maxR)` — 环形范围内随机点
- `RecastFindNearestPoint(point)` — 将点吸附到NavMesh表面

### 移动流程（服务端）

```
客户端 C2M_PathfindingResult(目标位置)
→ 服务端 PathfindingComponent.Find(当前位置, 目标位置)
→ 广播 M2C_PathfindingResult(路径点) 给周围玩家
→ MoveComponent.MoveToAsync(路径点, 速度)
→ 每帧插值更新Position → 触发AOI Move
→ 到达终点 → 发送 M2C_Stop
```

---

## 10. 地图资源

### 场景文件

位置：`Packages/cn.etetet.map/Bundles/Scenes/`

```
├── Lordaeron/
│   └── Location/        ← 场景子文件夹
└── Map1/
    └── *.unity          ← Unity场景文件
```

客户端通过 `MapConfig.MapResName` 加载对应场景。

### 单位预制体

位置：`Packages/cn.etetet.map/Bundles/Units/`

```
├── Bear.prefab
├── BearBoss.prefab
├── Boar.prefab
├── Character_HumanMale.prefab
├── Mage.prefab
├── Skeleton_Warrior.prefab
└── TrainingDummy.prefab
```

客户端根据 `UnitConfig.Name` 加载对应预制体：
```csharp
string assetsName = $"Packages/cn.etetet.map/Bundles/Units/{unit.Config().Name}.prefab";
```

### 寻路数据

位置：`Packages/cn.etetet.map/Bundles/Recast/`（见第9节）

### 配置JSON

位置：`Packages/cn.etetet.map/Bundles/Json/`

包含 AI、Buff、Spell 等配置的导出JSON文件。

---

## 11. Proto 消息一览

### 客户端消息（Map_C_11000.proto）

| 消息 | 方向 | 说明 |
|------|------|------|
| C2G_EnterMap / G2C_EnterMap | C→Gate→C | 请求进入地图，返回MyId |
| C2M_PathfindingResult | C→Map | 发送寻路目标位置 |
| C2M_Stop | C→Map | 请求停止移动 |
| C2M_TransferMap / M2C_TransferMap | C↔Map | 请求传送 |
| M2C_StartSceneChange | Map→C | 通知客户端切换场景 |
| M2C_CreateMyUnit | Map→C | 创建自己的Unit信息 |
| M2C_CreateUnits | Map→C | AOI进入视野，创建其他Unit |
| M2C_RemoveUnits | Map→C | AOI离开视野，移除Unit |
| M2C_PathfindingResult | Map→C | 广播寻路路径 |
| M2C_Stop | Map→C | 广播停止移动 |
| M2C_Turn | Map→C | 广播转向 |
| M2C_NumericChange | Map→C | 数值变化通知 |
| UnitInfo | — | Unit信息结构体（Id, ConfigId, Type, Position, Forward, KV, MoveInfo） |

### 服务端消息（Map_S_21000.proto）

| 消息 | 方向 | 说明 |
|------|------|------|
| M2M_UnitTransferRequest | Map→Map | 跨地图传送Unit（携带序列化数据） |
| M2M_UnitTransferResponse | Map→Map | 返回新ActorId |
| G2Map_Logout / Map2G_Logout | Gate↔Map | 玩家登出 |

### MapManager消息（MapManager_S_20800.proto）

| 消息 | 方向 | 说明 |
|------|------|------|
| A2MapManager_GetMapRequest | Any→MM | 请求分配地图副本 |
| A2MapManager_GetMapResponse | MM→Any | 返回MapActorId |
| A2MapManager_NotifyPlayerAlreadyEnterMapRequest | Any→MM | 通知玩家已进入 |
| MapManager2Map_NotifyPlayerTransferRequest | MM→Map | 通知地图有玩家要传入 |
| Map2MapManager_LogoutRequest | Map→MM | 玩家从地图登出 |

---

## 12. 如何新增一张地图

### 步骤清单

1. **制作Unity场景**
   - 在 `Packages/cn.etetet.map/Bundles/Scenes/` 下创建新文件夹（如 `MyMap/`）
   - 制作Unity场景文件

2. **导出寻路数据**
   - 使用 Recast 工具对场景地形导出 NavMesh
   - 将 `.bytes` 文件放入 `Packages/cn.etetet.map/Bundles/Recast/MyMap.bytes`

3. **配置 Map.xlsx**
   - 在 `Packages/cn.etetet.map/Luban/Config/Datas/Map.xlsx` 新增一行
   - 填写 Id、Name（如 "MyMap"）、CopyType、MaxLineNum、MaxPlayerNum、RecommendPlayerNum、MapResName

4. **配置 MapUnit.xlsx**
   - 在 `Packages/cn.etetet.map/Luban/Config/Datas/MapUnit.xlsx` 添加地图中的NPC/怪物
   - 每行指定 UnitConfigId、MapName="MyMap"、KV中填入位置坐标

5. **配置传送规则（可选）**
   - 在 `MapTransferRule.xlsx` 添加从其他地图传送到此地图的规则
   - 指定 ToMap="MyMap"、Pos=落点坐标

6. **导出配置**
   - 执行 Luban 导出，生成配置JSON和C#代码

7. **编译**
   - `dotnet build ET.sln`

8. **验证**
   - 启动服务器，通过传送或修改默认出生地图进入新地图
   - 检查寻路是否正常、NPC/怪物是否正确生成、AOI是否工作
