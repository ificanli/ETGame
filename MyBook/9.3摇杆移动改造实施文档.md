# 9.3 摇杆移动改造实施文档

## 1. 文档目的

本文件用于指导把当前“点击寻路/短目标寻路”移动方式，改造成“摇杆连续控制移动”。

目标是后续可以直接按本文件逐步实施，不再重复做方案讨论。

---

## 2. 当前实现现状（基线）

### 2.1 客户端输入链路

当前移动输入来自 `InputSystemComponentSystem`：

- `Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs:34`
- `Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs:82`

逻辑是每 100ms 取一次 `Move(Vector2)`，转成前方目标点，再调用：

- `unit.MoveToAsync(targetPos)`（客户端 MoveHelper）

对应文件：

- `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/MoveHelper.cs:10`

### 2.2 服务端移动链路

服务端收到 `C2M_PathfindingResult` 后执行：

- `unit.FindPathMoveToAsync(message.Position)`  
  文件：`Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/C2M_PathfindingResultHandler.cs:11`

`FindPathMoveToAsync` 会：

1. 调 `PathfindingComponent.Find` 求路径
2. 广播 `M2C_PathfindingResult`
3. 用 `MoveComponent.MoveToAsync` 按路径点插值移动

文件：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/MoveHelper.cs:9`
- `Packages/cn.etetet.recast/Scripts/Hotfix/Share/PathfindingComponentSystem.cs:52`
- `Packages/cn.etetet.move/Scripts/Hotfix/Share/MoveComponentSystem.cs:111`

### 2.3 已有能力可复用

1. 服务器有导航回贴能力  
`PathfindingComponent.RecastFindNearestPoint`  
文件：`Packages/cn.etetet.recast/Scripts/Hotfix/Share/PathfindingComponentSystem.cs:121`

2. 位置写回会自动触发 AOI 更新  
`Unit.Position` setter 发布 `ChangePosition` 事件  
文件：`Packages/cn.etetet.unit/Scripts/Model/Share/Unit.cs:26`

3. 服务端已有“停止移动”链路  
`MoveHelper.Stop` + `M2C_Stop`  
文件：`Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/MoveHelper.cs:40`

---

## 3. 改造目标与非目标

## 3.1 目标

1. 摇杆持续输入时，角色持续移动
2. 松开摇杆后角色立即停止（或极短缓停）
3. 保持服务端权威，不引入客户端权威位置
4. 不引入 `Rigidbody` 物理移动
5. 与现有 AOI、Turn、Move、NavMesh 体系兼容

## 3.2 非目标

1. 不做动力学碰撞推挤
2. 不改怪物 AI 移动
3. 不改技能系统逻辑

---

## 4. 方案选型

## 4.1 候选方案

1. 低成本方案：继续发短距离寻路请求（本质还是 pathfinding）
2. 推荐方案：摇杆输入上行，服务端连续积分移动，NavMesh 回贴

## 4.2 最终选择（推荐）

采用方案 2：**服务端连续驱动摇杆移动**。

原因：

1. 输入语义清晰（方向控制，不是目标点）
2. 避免频繁求路带来的抖动/取消协程开销
3. 可自然扩展加速度、滑步、冲刺等动作

---

## 5. 高层时序

1. 客户端采样摇杆向量（屏幕或手柄）
2. 转换为世界方向（受相机朝向影响）
3. 固定频率上报输入（带 `Seq`）
4. 服务端保存输入状态，按 Tick 推进位置
5. 每次推进后用 Recast 最近点回贴
6. 服务端按频率广播摇杆状态同步
7. 客户端插值显示，必要时对本地玩家回正

---

## 6. 协议设计（Proto）

修改文件：

- `Packages/cn.etetet.map/Proto/Map_C_11000.proto`

新增消息（建议）：

```proto
message C2M_JoystickInput // ILocationMessage
{
	int32 RpcId = 1;
	int32 Seq = 2;
	Unity.Mathematics.float3 MoveDir = 3; // 世界方向，y=0，长度[0,1]
	bool IsStop = 4;                      // 松开摇杆时true
	int64 ClientTime = 5;                 // 可选，用于调试时延
}

message M2C_JoystickState // IMessage
{
	int64 UnitId = 1;
	int32 AckSeq = 2;                     // 服务端已处理到的输入序号
	Unity.Mathematics.float3 Position = 3;
	Unity.Mathematics.quaternion Rotation = 4;
	Unity.Mathematics.float3 MoveDir = 5; // 当前服务端方向
	bool IsMoving = 6;
	int64 ServerTime = 7;
}
```

说明：

1. `MoveDir` 建议用世界坐标，降低服务端对相机信息依赖
2. `AckSeq` 便于客户端丢包诊断与回正
3. `IsStop` 明确停止语义，避免方向归零歧义

---

## 7. ECS 设计（符合 ET 架构规范）

遵循 `et-arch` 规范：

1. Entity/Component 仅放数据，不放业务方法
2. 业务逻辑放 `System`/`Helper`
3. await 后访问 Entity 必须使用 `EntityRef`

## 7.1 新增组件

建议新增：

- `Packages/cn.etetet.map/Scripts/Model/Share/Map/Unit/JoystickMoveComponent.cs`

字段建议：

```csharp
[ComponentOf(typeof(Unit))]
public class JoystickMoveComponent: Entity, IAwake
{
    public int LastSeq;
    public long LastInputTime;
    public float3 MoveDir;
    public bool IsMoving;
    public long MoveTimer;
    public long SyncTimer;
}
```

## 7.2 TimerInvokeType 扩展

修改：

- `Packages/cn.etetet.map/Scripts/Model/Share/TimerInvokeType.cs`

建议新增常量：

```csharp
public const int JoystickMoveTimer = PackageType.Map * 1000 + 3;
public const int JoystickSyncTimer = PackageType.Map * 1000 + 4;
```

---

## 8. 服务端改造详单

## 8.1 新增消息处理器

新增文件：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/C2M_JoystickInputHandler.cs`

职责：

1. 读取并校验 `Seq`
2. 归一化 `MoveDir`
3. 写入 `JoystickMoveComponent`
4. 第一次进入摇杆状态时停止旧路径移动

关键点：

1. 仅处理“自己的 Unit”
2. 不在 Handler 里做复杂位移循环
3. 复杂逻辑下沉到 `JoystickMoveComponentSystem/Helper`

## 8.2 新增 JoystickMoveComponentSystem

新增文件：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/JoystickMoveComponentSystem.cs`

建议方法：

1. `Awake`
2. `Start`（创建移动计时器）
3. `Stop`（停止计时器并发停止同步）
4. `TickMove`（按 dt 推进位置）
5. `TickSync`（按频率广播状态）

移动公式（服务端）：

```text
speed = unit.NumericComponent.GetAsFloat(NumericType.Speed)
delta = MoveDir * speed * dtSeconds
target = unit.Position + delta
unit.Position = pathfinding.RecastFindNearestPoint(target)
```

旋转建议：

1. `MoveDir` 有效时朝向 `MoveDir`
2. 用现有 `TurnComponent` 平滑转向或直接设置

## 8.3 兼容与互斥

收到摇杆输入时，先取消路径协程：

```csharp
unit.GetComponent<MoveComponent>()?.Stop(false);
```

超时停机：

1. 若 `Now - LastInputTime > InputTimeoutMs`，自动 `IsMoving=false`
2. 超时时发送一次 `M2C_JoystickState(IsMoving=false)`

## 8.4 挂载点

建议在以下位置给玩家挂 `JoystickMoveComponent`：

- `Packages/cn.etetet.map/Scripts/Hotfix/Server/Map/M2M_UnitTransferRequestHandler.cs`

按 `unit.UnitType == UnitType.Player` 条件挂载。

---

## 9. 客户端改造详单

## 9.1 InputAction 资产改造

修改：

- `Packages/cn.etetet.map/Settings/InputSystem.inputactions`

建议：

1. `Move` 去掉 `Hold(duration=0.2...)`（摇杆应即时响应）
2. 增加手柄绑定：`<Gamepad>/leftStick`
3. 若用屏幕虚拟摇杆，绑定到 `<Gamepad>/leftStick` 路径

注意：

1. `Packages/cn.etetet.map/Scripts/ModelView/Client/InputSystem.cs` 是生成文件
2. 修改 inputactions 后要重新生成该 C# 包装类

## 9.2 InputSystemComponent 扩展

修改：

- `Packages/cn.etetet.map/Scripts/ModelView/Client/InputSystemComponent.cs`

建议新增字段：

1. `int LastSendSeq`
2. `long LastSendTime`
3. `float3 LastSendDir`
4. `bool IsJoystickMode`

## 9.3 InputSystemComponentSystem 改造

修改：

- `Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs`

核心变化：

1. `Move(Vector2)` 不再调用 `unit.MoveToAsync(targetPos)`
2. 改为构建 `C2M_JoystickInput` 并发送
3. 发送频率建议 20Hz（配置化）
4. 方向变化大于阈值时立即发送（避免手感延迟）
5. 松手立即发 `IsStop=true`

世界方向转换保留现有相机逻辑：

```text
input2D -> cameraYaw -> worldDir(float3, y=0)
```

## 9.4 新增客户端状态处理器

新增：

- `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/M2C_JoystickStateHandler.cs`

建议行为：

1. 自己单位：做平滑回正（误差超过阈值时硬对齐）
2. 其他单位：插值到服务端状态（或直接设置，后续优化）

---

## 10. 配置设计（禁止硬编码）

建议新增一份移动控制配置（Luban）：

- `JoystickSendIntervalMs`（客户端发送周期）
- `JoystickDirEpsilon`（方向变化阈值）
- `JoystickInputTimeoutMs`（服务端输入超时）
- `JoystickSyncIntervalMs`（服务端广播周期）
- `JoystickMaxSpeedScale`（可选，全局倍率）
- `JoystickSelfSnapDistance`（自我回正硬阈值）

读取方式：

1. 通过配置表加载，不在代码写死数字
2. 允许按场景或角色类型覆盖

---

## 11. 逐文件改造清单（实施级）

## 11.1 必改文件

1. `Packages/cn.etetet.map/Proto/Map_C_11000.proto`
2. `Packages/cn.etetet.map/Scripts/Model/Share/TimerInvokeType.cs`
3. `Packages/cn.etetet.map/Scripts/ModelView/Client/InputSystemComponent.cs`
4. `Packages/cn.etetet.map/Scripts/HotfixView/Client/InputSystemComponentSystem.cs`
5. `Packages/cn.etetet.map/Scripts/Hotfix/Server/Map/M2M_UnitTransferRequestHandler.cs`
6. `Packages/cn.etetet.map/Settings/InputSystem.inputactions`

## 11.2 新增文件

1. `Packages/cn.etetet.map/Scripts/Model/Share/Map/Unit/JoystickMoveComponent.cs`
2. `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/C2M_JoystickInputHandler.cs`
3. `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/JoystickMoveComponentSystem.cs`
4. `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/JoystickMoveHelper.cs`（可选）
5. `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/M2C_JoystickStateHandler.cs`

## 11.3 可选调整文件

1. `Packages/cn.etetet.map/Scripts/Hotfix/Client/Move/MoveHelper.cs`（保留点击模式时增加模式分流）
2. `Packages/cn.etetet.map/Scripts/Hotfix/Server/Move/C2M_PathfindingResultHandler.cs`（摇杆模式下可拒绝路径消息）

---

## 12. 迁移阶段（推荐）

## 阶段 A：双模式并存（低风险）

1. 增加摇杆协议与系统
2. 保留点击寻路
3. 增加运行时开关（玩家/平台维度）

## 阶段 B：默认摇杆

1. 输入默认走摇杆链路
2. 点击寻路仅作为可选（例如 PC）

## 阶段 C：清理与收敛

1. 删除废弃逻辑分支
2. 收敛配置项
3. 补充自动化测试

---

## 13. 测试计划

## 13.1 功能测试

1. 摇杆轻推/重推，速度是否符合预期
2. 松开是否及时停止
3. 持续转圈是否平滑
4. 切场景后摇杆是否正常恢复
5. 与技能施法并发是否冲突

## 13.2 一致性测试

1. 客户端 A/B 看同一单位轨迹是否一致
2. 丢包、乱序下 `Seq` 是否稳定
3. 超时自动停是否生效

## 13.3 边界测试

1. 墙边贴边移动是否穿墙
2. NavMesh 缝边是否抖动
3. 低帧率下是否加速/减速异常

## 13.4 性能测试

1. 50/100 同屏玩家下 CPU 与网络包量
2. 广播频率变化对流量影响

---

## 14. 风险与规避

1. 风险：频繁同步导致带宽上涨  
规避：方向变化才发输入 + 服务端固定频率同步 + AOI 广播

2. 风险：客户端抖动明显  
规避：客户端插值 + 误差阈值分级回正

3. 风险：路径协程和摇杆协程互抢  
规避：摇杆启动时显式 `Stop(false)` 旧 `MoveComponent`

4. 风险：输入丢失导致“幽灵前进”  
规避：服务端 `InputTimeoutMs` 自动停机

---

## 15. 与现有软挤压方案的衔接

本改造与 `Book/9.2单位间软挤压方案.md` 兼容，推荐顺序：

1. 先完成摇杆连续移动
2. 再在服务端移动 Tick 后接入软挤压微调
3. 软挤压后做 Recast 回贴（避免出导航区）

---

## 16. 构建与验证命令（PowerShell）

> 按项目规范，命令使用 PowerShell。

1. Proto 导出（如你当前流程需要）：

```powershell
dotnet Bin/ET.Proto2CS.dll
```

2. 唯一编译命令：

```powershell
dotnet build ET.sln
```

---

## 17. 验收标准（DoD）

满足以下条件视为改造完成：

1. 玩家可通过摇杆连续移动，松手稳定停止
2. 服务端权威位置生效，客户端无明显漂移
3. 不发生穿墙，边界移动正常
4. 与现有技能、目标选择、AOI 同步共存
5. `dotnet build ET.sln` 通过

---

## 18. 备注

1. 本文是“实施文档”，后续编码按本文逐步落地
2. 若你决定“完全替换点击寻路”，实施时可在阶段 B 直接关闭 `C2M_PathfindingResult` 客户端发送
3. 若你决定“PC 点击 + 移动端摇杆并存”，建议保留模式开关并加平台判断

