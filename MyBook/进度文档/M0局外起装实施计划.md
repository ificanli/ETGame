# M0 局外起装实施计划

## 需求确认

| 维度 | 内容 |
|------|------|
| **英雄选择** | 玩家进局前通过UI选择英雄，M0用Excel配置，全部可用 |
| **英雄差异** | 外观模型、属性、技能各不相同 |
| **装备槽位** | 主武器、副武器、护甲、消耗品（共4个槽位） |
| **装备数据源** | M0先用Excel配置表 |
| **局内背包** | 有容量限制，拾取搜索物品 |
| **撤离结算** | 撤离成功=全部带出，死亡=全部丢失 |

---

## 计划审查 - 发现的问题

### 问题1（严重）：EquipmentComponent 不支持 ITransfer，传送后装备数据丢失

**现状**：
```csharp
// EquipmentComponent 当前定义
public class EquipmentComponent: Entity, IAwake, IDestroy  // 缺少 ITransfer, IDeserialize
```

**TransferHelper 传送逻辑**：
```csharp
foreach (Entity entity in unit.Components.Values.ToArray())
{
    if (entity is not ITransfer)
    {
        unit.RemoveComponent(entity.GetType());  // EquipmentComponent 会被移除！
    }
}
```

**对比 ItemComponent**（已正确实现）：
```csharp
public class ItemComponent: Entity, IAwake, IDestroy, IDeserialize, ITransfer  // ✅
```

**影响**：在 Gate 临时 Map 上创建的 Unit，通过 TransferHelper 传送到真实 Map 时，EquipmentComponent 会被删除。装备数据全部丢失。

**修复方案**：为 EquipmentComponent 添加 `ITransfer` 和 `IDeserialize` 接口，并实现 Deserialize 逻辑重建 EntityRef 引用。

---

### 问题2（中等）：Proto 文件位置与命名规范不一致

**现状**：各包的 proto 文件放在各自包的 `Proto/` 目录下：
- `cn.etetet.equipment/Proto/Equipment_C_4700.proto`
- `cn.etetet.item/Proto/Item_C_10800.proto`
- `cn.etetet.login/Proto/Login_C_10000.proto`

命名格式：`{Module}_{Scope}_{BaseId}.proto`

**原计划**：放在 `cn.etetet.proto/Proto/LoadoutMessage.proto`，命名不符合规范。

**修正方案**：新建 `Packages/cn.etetet.equipment/Proto/Loadout_C_4800.proto`，遵循包内 Proto 目录 + 命名规范。如果约束要求必须在 cn.etetet.proto 中，则文件名也应改为 `Loadout_C_4800.proto`。

---

### 问题3（中等）：死亡处理不能修改 spell 包

**现状**：玩家死亡事件 `UnitDie` 在 `cn.etetet.spell` 的 `DamageHelper.cs` 中发布：
```csharp
if (v == 0) // HP=0
{
    EventSystem.Instance.Publish(target.Scene(), new UnitDie { Unit = attacker, Target = target });
}
```

当前只有 `cn.etetet.quest` 订阅了 `UnitDie` 事件。

**原计划问题**：死亡处理位置不明确，且不能修改 spell 包。

**修正方案**：在 `cn.etetet.equipment` 包中新建 `UnitDieEvent_ClearLoadout` 事件处理器，订阅 `UnitDie` 事件。多个 Handler 可以订阅同一事件，互不影响。

```csharp
[Event(SceneType.Map)]
public class UnitDieEvent_ClearLoadout : AEvent<Scene, UnitDie>
{
    protected override async ETTask Run(Scene scene, UnitDie a) { ... }
}
```

---

### 问题4（低）：LoadoutComponent 挂在 Player 上需要跨包访问

**现状**：`Player` 定义在 `cn.etetet.login` 包中。`LoadoutComponent` 计划放在 `cn.etetet.equipment` 包。

**验证结果**：两个包都在 Layer 5，login 包设置了 `AllowSameLevelAccess: true`。因此 equipment 包**可以**访问 login 包的 Player 类型。**无需修改依赖**。

---

### 问题5（低）：PlayerStorageComponent 在断线时丢失

**现状**：Player 实体在会话断开时被销毁。挂在 Player 上的 PlayerStorageComponent 会随之销毁。

**M0 影响**：M0 以内存存储为主，仅用于验证流程。玩家断线重连后存储丢失是可接受的。

**后续方案**：M1 版本引入数据库持久化（MongoDB/Redis），在 PlayerStorageComponent 的 IDestroy 中保存到 DB，IAwake 中从 DB 加载。

---

### 问题6（注意）：C2G_EnterMapHandler 在 map 包中，需访问 equipment 包类型

**现状**：`C2G_EnterMapHandler` 在 `cn.etetet.map` 包。修改它需要引用 equipment 包的 `LoadoutComponent` 和 `HeroConfig`。

**验证结果**：map 和 equipment 都在 Layer 5，equipment 设置了 `AllowSameLevelAccess: true`。map 包**可以**访问 equipment 包类型。但需要确认 map 包的 csproj 中添加了对 equipment 的引用。

**替代方案**：不修改 C2G_EnterMapHandler，而是在 equipment 包中通过事件机制（如订阅 EnterMap 相关事件）注入装备初始化逻辑。但这会增加复杂度，M0 建议直接修改。

---

## 现状分析

| 系统 | 现状 | 缺口 |
|------|------|------|
| **英雄选择** | 不存在，UnitFactory 硬编码 configId=1001 | 需要英雄配置表、选择流程 |
| **装备槽位** | 有9种（Head~Accessory2），缺少消耗品槽 | M0需4槽：主武器、副武器、护甲、消耗品 |
| **装备系统** | EquipmentComponent 完整，但缺少 ITransfer/IDeserialize | **需先修复传送丢失 bug** |
| **背包系统** | ItemComponent 完整，默认容量100 | 可直接使用 |
| **撤离逻辑** | case 1 只做传送到Map1 | 需加入物品结算逻辑 |
| **结算写回** | 不存在 | 需要简单的局外存储机制 |
| **死亡处理** | UnitDie 事件可订阅，不需改 spell 包 | 需在 equipment 包新增事件处理器 |
| **Proto** | 无 LoadoutMessage.proto | 需新建（遵循命名规范） |

---

## 修正后的实施步骤

### 步骤0（前置修复）：EquipmentComponent 添加 ITransfer 支持

**位置**: `Packages/cn.etetet.equipment/Scripts/Model/Server/EquipmentComponent.cs`（修改）

```csharp
[ComponentOf(typeof(Unit))]
public class EquipmentComponent: Entity, IAwake, IDestroy, ITransfer, IDeserialize
{
    public Dictionary<EquipmentSlotType, EntityRef<Item>> EquippedItems = new();
}
```

**新增** `EquipmentComponentSystem` 中的 `Deserialize` 方法：传送后重建 EntityRef 引用。

**对应测试**: `Equipment_Transfer_Test` — 验证装备数据在传送后保持完整。

---

### 步骤1：新建 Proto 消息定义

**位置**: `Packages/cn.etetet.equipment/Proto/Loadout_C_4800.proto`（新建）

```protobuf
// 英雄数据（用于列表展示）
message HeroInfoData
{
    int32 HeroConfigId = 1;
    string Name = 2;
    int32 UnitConfigId = 3;
}

// 请求可用英雄列表
message C2G_GetHeroList // ISessionRequest
message G2C_GetHeroList // ISessionResponse
{
    repeated HeroInfoData Heroes = 1;
}

// 确认起装
message C2G_ConfirmLoadout // ISessionRequest
{
    int32 HeroConfigId = 1;
    int32 MainWeaponConfigId = 2;
    int32 SubWeaponConfigId = 3;
    int32 ArmorConfigId = 4;
    repeated int32 ConsumableConfigIds = 5;
}
message G2C_ConfirmLoadout // ISessionResponse

// 撤离结算通知
message M2C_EvacuationSettlement // IMessage
{
    bool Success = 1;
    repeated ItemData Items = 2;
    int64 TotalWealth = 3;
}

// 死亡结算通知
message M2C_DeathSettlement // IMessage
```

---

### 步骤2：新建英雄配置表 HeroConfig

**位置**: `Packages/cn.etetet.equipment/Luban/Config/Datas/Hero.xlsx`（新建）

| 字段 | 类型 | 说明 |
|------|------|------|
| Id | int | 英雄ID |
| Name | string | 英雄名称 |
| UnitConfigId | int | 对应的UnitConfig ID（决定属性、技能） |
| DefaultMainWeapon | int | 默认主武器 ItemConfig ID |
| DefaultSubWeapon | int | 默认副武器 ItemConfig ID |
| DefaultArmor | int | 默认护甲 ItemConfig ID |

需要同步修改 `__beans__.xlsx`、`__tables__.xlsx` 注册新表。

---

### 步骤3：扩展 EquipmentSlotType

**位置**: `Packages/cn.etetet.equipment/Scripts/Model/Share/EquipmentSlotType.cs`（修改）

在现有枚举中增加消耗品槽位：

```csharp
Consumable1 = 10,  // 消耗品1
Consumable2 = 11,  // 消耗品2
```

M0 实际使用的4个槽位映射：
- 主武器 → MainHand (6)
- 副武器 → OffHand (7)
- 护甲 → Chest (2)
- 消耗品 → Consumable1 (10)

---

### 步骤4：新建 LoadoutComponent（服务端+客户端）

**服务端** `LoadoutComponent`（挂在 Player 上，Gate 阶段存在）：

**位置**: `Packages/cn.etetet.equipment/Scripts/Model/Server/LoadoutComponent.cs`（新建）

```csharp
[ComponentOf(typeof(Player))]
public class LoadoutComponent : Entity, IAwake, IDestroy
{
    public int HeroConfigId;
    public int MainWeaponConfigId;
    public int SubWeaponConfigId;
    public int ArmorConfigId;
    public List<int> ConsumableConfigIds;
    public bool IsConfirmed;
}
```

**客户端** `LoadoutComponent`（挂在 Scene 上）：

**位置**: `Packages/cn.etetet.equipment/Scripts/Model/Client/LoadoutComponent.cs`（新建）

---

### 步骤5：实现起装选择 Handler

**位置**: `Packages/cn.etetet.equipment/Scripts/Hotfix/Server/`（新建）

#### C2G_GetHeroListHandler
- `[MessageSessionHandler(SceneType.Gate)]`
- 从 HeroConfigCategory 读取所有英雄配置
- 返回英雄列表给客户端

#### C2G_ConfirmLoadoutHandler
- `[MessageSessionHandler(SceneType.Gate)]`
1. 从 Session 获取 Player
2. 验证 HeroConfigId 存在
3. 验证各装备 ConfigId 存在且槽位类型匹配
4. 创建/更新 Player 的 LoadoutComponent
5. 标记 IsConfirmed = true

---

### 步骤6：修改 Unit 创建流程 — 装备携带进局

**位置**: `Packages/cn.etetet.map/Scripts/Hotfix/Server/C2G_EnterMapHandler.cs`（修改）

修改逻辑：
1. 读取 Player 上的 LoadoutComponent
2. 获取 HeroConfig，使用 HeroConfig.UnitConfigId 替换硬编码的 1001
3. 调用 `UnitFactory.Create(scene, player.Id, heroConfig.UnitConfigId)`
4. 为 Player Unit 添加 EquipmentComponent
5. 通过 `LoadoutHelper.ApplyLoadout(unit, loadoutComponent)` 创建装备 Item 并装入对应槽位

```
流程图：
登录 → 选英雄/装备(Gate) → 确认起装(存LoadoutComponent)
    → C2G_EnterMap → 读取LoadoutComponent → UnitFactory.Create(heroConfigId)
    → AddComponent<EquipmentComponent> → ApplyLoadout → TransferToMap
    → Map侧收到Unit（装备通过ITransfer保留）
```

---

### 步骤7：局内背包

- ItemComponent 已在 UnitFactory 中为 Player 自动添加
- 拾取逻辑已有（ItemHelper.AddItem），与工程3的容器交互对接
- 无需额外修改

---

### 步骤8：修改撤离逻辑 case 1 — 奖励结算

**位置**: `Packages/cn.etetet.ecanode/Scripts/Hotfix/Server/PlayerEvacuationComponentSystem.cs`（修改）

修改 `CompleteEvacuation` 方法，在传送到 Map1 之前：

1. 收集玩家背包中所有物品（ItemComponent.SlotItems）
2. 收集玩家装备中所有装备（EquipmentComponent.EquippedItems）
3. 计算总财富值
4. 发送 `M2C_EvacuationSettlement` 给客户端
5. 传送到 Map1（已有逻辑）

**约束**: 只修改 case 1 (EvacuationPoint)，不触碰 case 2/3

---

### 步骤9：死亡惩罚 — 全丢逻辑

**位置**: `Packages/cn.etetet.equipment/Scripts/Hotfix/Server/UnitDieEvent_ClearLoadout.cs`（新建）

```csharp
[Event(SceneType.Map)]
public class UnitDieEvent_ClearLoadout : AEvent<Scene, UnitDie>
{
    protected override async ETTask Run(Scene scene, UnitDie a)
    {
        Unit target = a.Target;
        if (target.UnitType != UnitType.Player) return;

        // 1. 清空局内背包
        // 2. 清空装备
        // 3. 发送 M2C_DeathSettlement
    }
}
```

不修改 spell 包，通过事件订阅机制实现。

---

### 步骤10：结算写回 — PlayerStorageComponent

**位置**: `Packages/cn.etetet.equipment/Scripts/Model/Server/PlayerStorageComponent.cs`（新建）

M0 使用简单的内存存储：

```csharp
[ComponentOf(typeof(Player))]
public class PlayerStorageComponent : Entity, IAwake, IDestroy
{
    public List<StorageItemData> Items;
    public long Wealth;
}
```

- 挂在 Gate 的 Player 上，跨战局保持
- 撤离成功：将物品添加到存储
- M0 局限：断线后丢失，M1 引入 DB 持久化

---

## 涉及文件变更清单

| 包 | 文件 | 操作 |
|-----|------|------|
| cn.etetet.equipment | `Scripts/Model/Server/EquipmentComponent.cs` | **修改** — 添加 ITransfer, IDeserialize |
| cn.etetet.equipment | `Scripts/Hotfix/Server/EquipmentComponentSystem.cs` | **修改** — 添加 Deserialize 方法 |
| cn.etetet.equipment | `Proto/Loadout_C_4800.proto` | **新建** |
| cn.etetet.equipment | `Luban/Config/Datas/Hero.xlsx` | **新建** |
| cn.etetet.equipment | `Luban/Config/Base/__beans__.xlsx` | **修改** |
| cn.etetet.equipment | `Luban/Config/Base/__tables__.xlsx` | **修改** |
| cn.etetet.equipment | `Scripts/Model/Share/EquipmentSlotType.cs` | **修改** — 增加消耗品槽位 |
| cn.etetet.equipment | `Scripts/Model/Server/LoadoutComponent.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Model/Client/LoadoutComponent.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Hotfix/Server/LoadoutComponentSystem.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Hotfix/Server/LoadoutHelper.cs` | **新建** — ApplyLoadout 逻辑 |
| cn.etetet.equipment | `Scripts/Hotfix/Server/C2G_GetHeroListHandler.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Hotfix/Server/C2G_ConfirmLoadoutHandler.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Hotfix/Server/UnitDieEvent_ClearLoadout.cs` | **新建** — 死亡清空 |
| cn.etetet.equipment | `Scripts/Model/Server/PlayerStorageComponent.cs` | **新建** |
| cn.etetet.equipment | `Scripts/Hotfix/Server/PlayerStorageComponentSystem.cs` | **新建** |
| cn.etetet.map | `Scripts/Hotfix/Server/C2G_EnterMapHandler.cs` | **修改** — 读取loadout初始化Unit |
| cn.etetet.ecanode | `Scripts/Hotfix/Server/PlayerEvacuationComponentSystem.cs` | **修改** — case 1 增加结算 |

---

## TDD 测试设计

### 测试总览

按TDD流程，每个步骤先写测试，再实现代码让测试通过。

| # | 测试名 | 所在包 | 验证内容 | 对应步骤 |
|---|--------|--------|---------|---------|
| T0 | `Equipment_Transfer_Test` | equipment | 装备数据传送后保持完整 | 步骤0 |
| T1 | `Equipment_LoadoutConfirm_Test` | equipment | 起装选择和确认流程 | 步骤4-5 |
| T2 | `Equipment_LoadoutEnterMap_Test` | equipment | 装备携带进局，Unit有正确装备 | 步骤6 |
| T3 | `Equipment_LoadoutInvalidHero_Test` | equipment | 无效英雄ID被拒绝 | 步骤5 |
| T4 | `Equipment_LoadoutSlotMismatch_Test` | equipment | 装备与槽位不匹配被拒绝 | 步骤5 |
| T5 | `Ecanode_EvacuationWithItems_Test` | ecanode | 撤离时正确收集物品和财富 | 步骤8 |
| T6 | `Equipment_DeathClearAll_Test` | equipment | 死亡后背包和装备全部清空 | 步骤9 |
| T7 | `Equipment_StorageAfterEvacuation_Test` | equipment | 撤离后物品写入局外存储 | 步骤10 |
| T8 | `Equipment_FullFlow_Test` | equipment | 起装→进局→拾取→撤离→写回 完整流程 | 全部 |

### 测试详细设计

#### T0: Equipment_Transfer_Test — 装备传送完整性

```
前置条件：创建 Robot 并进入地图
步骤：
  1. 获取服务端 Unit
  2. 为 Unit 添加 EquipmentComponent
  3. 创建装备 Item 并装入 MainHand 槽位
  4. 验证装备已穿戴
  5. 执行 TransferHelper 传送到另一个 Map
  6. 传送后重新获取 Unit
  7. 验证 EquipmentComponent 仍然存在
  8. 验证 MainHand 槽位的装备 ConfigId 正确
验证点：
  - EquipmentComponent 不为 null（错误码 1）
  - EquippedItems 数量正确（错误码 2）
  - 装备 ConfigId 匹配（错误码 3）
```

#### T1: Equipment_LoadoutConfirm_Test — 起装确认流程

```
前置条件：创建 Robot，登录到 Gate
步骤：
  1. 发送 C2G_GetHeroList 请求
  2. 验证返回的英雄列表非空
  3. 选择第一个英雄
  4. 发送 C2G_ConfirmLoadout（英雄ID + 主武器 + 副武器 + 护甲 + 消耗品）
  5. 验证返回成功
  6. 在服务端验证 Player 上的 LoadoutComponent 数据正确
验证点：
  - 英雄列表非空（错误码 1）
  - ConfirmLoadout 返回成功（错误码 2）
  - LoadoutComponent.HeroConfigId 正确（错误码 3）
  - LoadoutComponent.MainWeaponConfigId 正确（错误码 4）
  - LoadoutComponent.IsConfirmed == true（错误码 5）
```

#### T2: Equipment_LoadoutEnterMap_Test — 装备携带进局

```
前置条件：创建 Robot，确认起装
步骤：
  1. 确认起装（选择英雄和装备）
  2. 发送 C2G_EnterMap 进入地图
  3. 获取服务端 Unit
  4. 验证 Unit.ConfigId == HeroConfig.UnitConfigId
  5. 验证 EquipmentComponent 存在
  6. 验证 MainHand 槽位有装备且 ConfigId 正确
  7. 验证 OffHand 槽位有装备且 ConfigId 正确
  8. 验证 Chest 槽位有装备且 ConfigId 正确
验证点：
  - Unit.ConfigId 与英雄配置匹配（错误码 1）
  - EquipmentComponent 存在（错误码 2）
  - MainHand 装备正确（错误码 3）
  - OffHand 装备正确（错误码 4）
  - Chest 装备正确（错误码 5）
  - ItemComponent 存在且可用（错误码 6）
```

#### T3: Equipment_LoadoutInvalidHero_Test — 无效英雄拒绝

```
步骤：
  1. 发送 C2G_ConfirmLoadout，HeroConfigId 使用不存在的 ID（99999）
  2. 验证返回错误码（非 ERR_Success）
验证点：
  - 返回值不为 0（错误码 1）
```

#### T4: Equipment_LoadoutSlotMismatch_Test — 槽位不匹配拒绝

```
步骤：
  1. 发送 C2G_ConfirmLoadout，MainWeaponConfigId 使用一个护甲的 ConfigId
  2. 验证返回错误码
验证点：
  - 返回值不为 0（错误码 1）
```

#### T5: Ecanode_EvacuationWithItems_Test — 撤离物品收集

```
前置条件：创建 Robot，进入地图，背包中有物品
步骤：
  1. 进入地图
  2. 服务端为 Unit 背包添加测试物品（ConfigId=10001, Count=5）
  3. 触发撤离流程（进入撤离点范围，等待倒计时完成）
  4. 验证 M2C_EvacuationSettlement 消息被发送
  5. 验证消息中的物品列表包含正确的物品
  6. 验证 TotalWealth 值正确
验证点：
  - 收到结算消息（错误码 1）
  - 物品列表包含 ConfigId=10001（错误码 2）
  - 物品数量 = 5（错误码 3）
  - 财富值 > 0（错误码 4）
```

#### T6: Equipment_DeathClearAll_Test — 死亡全丢

```
前置条件：创建 Robot，进入地图，有装备和背包物品
步骤：
  1. 进入地图
  2. 服务端为 Unit 添加装备和背包物品
  3. 触发玩家死亡（设置 HP=0，发布 UnitDie 事件）
  4. 验证 ItemComponent 背包已清空
  5. 验证 EquipmentComponent 装备已清空
  6. 验证客户端收到 M2C_DeathSettlement
验证点：
  - 背包物品数 == 0（错误码 1）
  - 装备数 == 0（错误码 2）
  - 收到死亡结算消息（错误码 3）
```

#### T7: Equipment_StorageAfterEvacuation_Test — 撤离写回存储

```
前置条件：创建 Robot，进入地图并撤离成功
步骤：
  1. 进入地图，背包添加物品
  2. 撤离成功
  3. 验证 Player 的 PlayerStorageComponent 中包含带出的物品
  4. 验证 Wealth 正确增加
验证点：
  - PlayerStorageComponent 存在（错误码 1）
  - Items 列表非空（错误码 2）
  - Wealth > 0（错误码 3）
```

#### T8: Equipment_FullFlow_Test — 完整流程集成测试

```
步骤：
  1. 登录
  2. 获取英雄列表
  3. 确认起装（英雄 + 武器 + 护甲）
  4. 进入地图
  5. 验证服务端 Unit 有正确英雄配置和装备
  6. 服务端为 Unit 背包添加物品（模拟拾取）
  7. 触发撤离
  8. 等待撤离完成
  9. 验证结算数据正确
  10. 验证局外存储数据正确
验证点：
  - 英雄列表获取成功（错误码 1）
  - 起装确认成功（错误码 2）
  - 进入地图成功（错误码 3）
  - Unit ConfigId 正确（错误码 4）
  - 装备正确（错误码 5）
  - 撤离完成（错误码 6）
  - 结算数据正确（错误码 7）
  - 存储数据正确（错误码 8）
```

---

## TDD 开发顺序

```
第一轮：基础修复
  编写 T0 (Equipment_Transfer_Test) → 实现步骤0 → 测试通过

第二轮：基础设施
  步骤1-3（Proto、配置表、枚举）→ 编译验证

第三轮：起装选择
  编写 T1 + T3 + T4 → 实现步骤4-5 → 测试通过

第四轮：携带进局
  编写 T2 → 实现步骤6 → 测试通过

第五轮：撤离结算
  编写 T5 → 实现步骤8 → 测试通过

第六轮：死亡惩罚
  编写 T6 → 实现步骤9 → 测试通过

第七轮：结算写回
  编写 T7 → 实现步骤10 → 测试通过

第八轮：集成测试
  编写 T8 → 全流程验证 → 回归测试
```

---

## 约束提醒

- **只新建** Proto 文件，不修改已有 proto
- **只修改** ecanode 中 case 1，不触碰 case 2/3
- **禁止修改**: eca Editor、spell 核心、match/battle、statesync InputSystem
- 死亡处理通过事件订阅，不修改 spell 包
- 所有命令使用 PowerShell
- 编译命令: `dotnet build ET.sln`
- 绝对禁止 hard code
- 测试命名: `{PackageType}_{Name}_Test`
- 测试错误码直接用数字，不定义常量

---

最后更新时间：2026-02-27
