# 战斗操作和相机操作需求文档

## 1. 文档目的

本文档定义局内战斗操作和相机操作的功能需求，用于指导后续的设计和实现工作。

---

## 2. 需求概述

### 2.1 核心目标

1. 实现基于摇杆的角色移动控制
2. 实现固定俯视角相机系统
3. 实现双枪械射击系统（局外装备）
4. 保持服务端权威，确保战斗公平性

### 2.2 适用场景

- 移动端竖屏射击游戏
- 俯视角战斗场景
- 多人在线对战
- 局外装备系统（双枪械）

---

## 3. 移动操作需求

### 3.1 摇杆移动

#### 3.1.1 功能描述

玩家通过屏幕虚拟摇杆控制角色移动，摇杆方向决定移动方向，摇杆偏移量决定移动速度。

#### 3.1.2 详细需求

1. **摇杆输入**
   - 支持屏幕虚拟摇杆（触摸输入）
   - 摇杆中心点可配置（固定位置或触摸点）
   - 摇杆最大偏移半径可配置

2. **移动控制**
   - 摇杆推动时角色持续移动
   - 移动方向与摇杆方向一致（世界坐标系）
   - 移动速度固定（由角色属性决定，不受摇杆偏移量影响）
   - 松开摇杆时角色立即停止

3. **方向转换**
   - 摇杆输入（屏幕 2D 坐标）转换为世界 3D 方向
   - 考虑相机朝向进行坐标转换
   - Y 轴方向固定为 0（水平移动）

4. **角色朝向**
   - 移动时角色朝向移动方向
   - 支持平滑转向（可配置转向速度）
   - 停止时保持最后朝向

#### 3.1.3 技术要求

**核心架构**：

1. **统一到 MoveComponent**（不新增 JoystickMoveComponent）
   - 在现有 `MoveComponent` 中新增 `MoveMode` 枚举（Path/Joystick）
   - 避免两个移动组件冲突
   - 代码复用，易于维护

2. **客户端预测**（必须实现）
   - 客户端发送输入后立即本地预测移动
   - 记录预测历史（用于服务端回正）
   - 收到服务端状态时根据误差分级回正：
     - 误差 > 0.5m：硬对齐
     - 误差 0.1-0.5m：平滑插值
     - 误差 < 0.1m：信任客户端预测

3. **服务端 Tick 频率**
   - 服务端移动 Tick：30Hz（33ms 间隔）
   - 客户端输入上报：20Hz
   - 服务端状态广播：15-30Hz（仅在变化时）
   - 说明：12 人同屏可以使用更高频率，提升移动流畅度

4. **NavMesh 回贴优化**
   - 条件回贴：距离上次回贴位置 > 1.0m 时才查询
   - 避免每次 Tick 都查询 NavMesh（性能优化）

5. **输入序列号处理**
   - 使用循环比较处理 Seq 溢出
   - 防止长时间运行后 Seq 溢出导致移动失效

**详细实现**：

```csharp
// 1. MoveComponent 扩展（不新增组件）
public class MoveComponent : Entity
{
    public MoveMode Mode;  // Path 或 Joystick
    public float3 JoystickDir;
    public int LastSeq;
    public float3 LastNavMeshPos;  // 上次 NavMesh 回贴位置
    // ... 其他原有字段
}

// 2. 客户端预测
public static void SendJoystickInput(this InputSystemComponent self, float3 dir)
{
    // 发送到服务端
    C2M_JoystickInput msg = C2M_JoystickInput.Create();
    msg.MoveDir = dir;
    msg.Seq = ++self.LastSendSeq;
    self.Send(msg);

    // 立即本地预测
    Unit myUnit = self.GetMyUnit();
    myUnit.Position += dir * speed * Time.deltaTime;
}

// 3. 服务端条件回贴
public static void TickMove(this MoveComponent self)
{
    Unit unit = self.GetParent<Unit>();
    float3 targetPos = unit.Position + self.JoystickDir * speed * dt;

    // 只在必要时回贴
    if (math.distance(targetPos, self.LastNavMeshPos) > 1.0f)
    {
        targetPos = pathfinding.RecastFindNearestPoint(targetPos);
        self.LastNavMeshPos = targetPos;
    }

    unit.Position = targetPos;
}

// 4. Seq 循环比较
public static bool IsSeqNewer(int newSeq, int oldSeq)
{
    int diff = newSeq - oldSeq;
    if (diff > 0 && diff < 1000) return true;
    if (diff < -2000000000) return true;  // 溢出回滚
    return false;
}
```

**安全防护**：

1. **输入频率限制**：服务端限制最小间隔 40ms（最高 25Hz）
2. **速度限制**：服务端限制最大移动速度
3. **异常检测**：检测超速移动、瞬移等异常行为
4. **输入校验**：校验 MoveDir 长度是否合法（≤ 1.1）

**超时处理**：

1. 输入超时 0.5 秒：开始减速
2. 输入超时 1.0 秒：完全停止
3. 防止网络断开后"幽灵前进"

### 3.2 与现有系统的关系

1. **扩展 MoveComponent（不新增组件）**
   - 在现有 `MoveComponent` 中新增 `MoveMode` 枚举
   - Path 模式：原有路径移动（寻路）
   - Joystick 模式：摇杆连续移动
   - 避免组件冲突，代码复用

2. **兼容性要求**
   - 与 NavMesh 导航系统兼容
   - 与 AOI 同步系统兼容
   - 与射击系统兼容（步枪移动限制）
   - 不影响怪物 AI 移动（AI 继续使用 Path 模式）

3. **技能位移处理**
   - 技能位移（如冲锋）时临时切换到 Path 模式
   - 技能结束后恢复 Joystick 模式

---

## 4. 相机操作需求

### 4.1 固定俯视角相机

#### 4.1.1 功能描述

相机以固定俯视角度跟随玩家角色，提供稳定的战斗视野。

#### 4.1.2 详细需求

1. **相机参数**
   - 俯视角度：固定（建议 45-60 度，可配置）
   - 相机高度：固定（可配置）
   - 相机距离：固定（可配置）
   - 视野范围（FOV）：固定（可配置）

2. **跟随行为**
   - 相机自动跟随玩家角色移动
   - 跟随方式：平滑跟随（可配置跟随速度）
   - 保持相机与角色的相对位置不变
   - 角色移动时相机同步移动

3. **相机约束**
   - 相机不可旋转（固定朝向）
   - 相机不可缩放（固定距离）
   - 相机不可手动拖拽
   - 相机角度固定，不受角色朝向影响

4. **边界处理**
   - 相机跟随时不穿透地形
   - 场景边界时相机停止跟随（角色可继续移动）
   - 可选：相机碰撞检测（遇到障碍物自动调整）

#### 4.1.3 技术要求

**基于现有 Cinemachine 实现改造**：

1. **复用现有组件**
   - 使用现有的 `CinemachineComponent`（`Packages/cn.etetet.map/Scripts/ModelView/Client/CinemachineComponent.cs`）
   - 使用现有的 `CinemachineVirtualCamera`
   - 保留 Follow Transform 机制

2. **改造要点**
   - 新增 `CameraMode` 字段（固定俯视/自由视角）
   - 固定俯视模式：
     - 禁用 `RotationFollow` 方法
     - 设置固定的 Follow Transform 角度（如 45 度俯视）
     - 锁定相机距离和高度
   - 保留跟随角色头部的逻辑

3. **配置管理**
   - 相机参数通过 Luban 配置表管理（禁止硬编码）
   - 支持不同场景使用不同相机配置
   - 配置项参考 8.2 相机配置表

4. **Cinemachine 设置**
   - Body：Transposer（位置跟随）
   - Aim：Composer（注视目标）
   - 或使用 Hard Lock to Target（固定跟随）

### 4.2 相机配置

**基于现有实现的建议配置项**：

- `CameraMode`：相机模式（0=固定俯视，1=自由视角）
- `CameraAngle`：俯视角度（度，建议 45）
- `CameraHeight`：相机高度（米，建议 5-8）
- `CameraDistance`：相机距离（米，建议 8-12）
- `CameraFOV`：视野范围（度，建议 50）
- `FollowDamping`：跟随阻尼（平滑度，建议 1.0）
- `LookAtOffset`：注视点偏移（Vector3）
- `EnableCollision`：是否启用碰撞检测

**当前实现参考**：
- 跟随目标：角色头部（Head BindPoint）
- 俯仰角限制：10-80 度（自由视角模式）
- 旋转灵敏度：1/5（自由视角模式）

---

## 5. 阵营与索敌系统需求

### 5.1 阵营系统

#### 5.1.1 功能描述

玩家进入地图时分配到不同阵营，同阵营玩家为友方，不同阵营玩家为敌方。阵营决定了自动射击的目标选择。

#### 5.1.2 详细需求

1. **阵营分配**
   - 玩家进入地图时由服务端分配阵营
   - 阵营类型：
     - 单人模式：每个玩家独立阵营（互相敌对）
     - 组队模式：队伍为一个阵营（队友友好，其他敌对）
     - 多阵营模式：多个队伍分配到不同阵营（如红蓝对抗）

2. **阵营标识**
   - 每个 Unit 有阵营 ID（CampId）
   - 阵营关系：友方、敌方、中立
   - 阵营关系通过配置表管理

3. **阵营显示**
   - 友方玩家：绿色名字/血条
   - 敌方玩家：红色名字/血条
   - 中立单位：黄色名字/血条
   - 小地图上显示阵营颜色

4. **阵营规则**
   - 同阵营玩家不可互相攻击
   - 不同阵营玩家可以互相攻击
   - 中立单位可被所有阵营攻击

#### 5.1.3 技术要求

1. Unit 添加 `CampId` 字段
2. 新增 `CampComponent` 管理阵营关系
3. 阵营关系通过 Luban 配置表管理
4. 进入地图时服务端分配阵营并同步客户端

### 5.2 索敌系统

#### 5.2.1 功能描述

自动检测射程范围内的敌方目标，按优先级选择攻击目标。支持目标切换和目标丢失处理。

#### 5.2.2 详细需求

1. **目标检测**
   - 使用 AOI 系统查询射程范围内的所有单位
   - 过滤出敌方单位（不同阵营）
   - 排除已死亡、无敌、隐身等状态的单位
   - 检测频率：每 100-200ms 检测一次（可配置）

2. **目标选择优先级**
   - 优先级 1：正在攻击自己的敌方玩家
   - 优先级 2：最近的敌方玩家
   - 优先级 3：最近的敌方精英怪
   - 优先级 4：最近的敌方普通怪
   - 优先级可通过配置表调整

3. **目标切换规则**
   - 当前目标死亡：立即切换到下一个目标
   - 当前目标离开射程：保持 0.5 秒，超时后切换
   - 当前目标进入无敌/隐身：立即切换
   - 更高优先级目标出现：有切换冷却时间（防止频繁切换）
   - **手动切换目标**：玩家点击 UI 按钮切换到下一个目标（无冷却限制）

4. **手动切换目标（UI 按钮）**
   - UI 按钮位置：屏幕右侧（切换枪械按钮附近）
   - 点击按钮：切换到下一个优先级目标
   - 切换逻辑：按优先级顺序循环切换
   - 无目标时：按钮置灰不可点击
   - 只有一个目标时：按钮置灰不可点击
   - 手动切换无冷却限制（与自动切换的冷却独立）

4. **目标丢失处理**
   - 射程内无敌方目标：停止射击
   - 目标死亡：停止射击，重新索敌
   - 目标离开射程：短暂追踪（0.5 秒），超时后停止

5. **视野限制（可选）**
   - 障碍物遮挡的目标不可选择
   - 使用射线检测判断视野遮挡
   - 可配置是否启用视野限制

#### 5.2.3 技术要求

1. 新增 `TargetSelectorComponent` 管理目标选择
2. 使用 AOI 系统查询范围内单位
3. 使用 Timer 定时检测目标（100-200ms）
4. 目标优先级通过配置表管理
5. 支持射线检测视野遮挡（可选）

---

## 6. 射击系统需求

### 6.1 局外装备系统

#### 5.1.1 功能描述

玩家在局外可以装备 2 把枪械，进入地图后携带这 2 把枪械进行战斗。不同枪械有不同的射击特性和移动限制。

#### 5.1.2 详细需求

1. **枪械装备**
   - 局外可装备 2 把枪械（主武器、副武器）
   - 进入地图时携带装备的枪械
   - 局内可切换使用两把枪械

2. **枪械类型**

   **步枪类**
   - 只能在停止移动时射击
   - 移动时无法射击
   - 射击精度高，伤害高
   - 适合定点输出

   **冲锋枪类**
   - 可以边移动边射击
   - 移动时射击精度略有下降
   - 射速快，伤害中等
   - 适合机动作战

   **其他枪械类型（可扩展）**
   - 狙击枪：高伤害，必须静止
   - 霰弹枪：近距离，可移动
   - 等等...

3. **枪械配置**
   - 每把枪械有独立的配置（伤害、射程、射速、弹药等）
   - 通过 Luban 配置表管理
   - 支持后续添加新枪械类型

### 6.2 自动射击系统

#### 6.2.1 功能描述

角色自动攻击射程范围内的敌方目标，无需手动点击射击按钮。射击方向自动朝向目标。依赖阵营系统和索敌系统。

#### 6.2.2 详细需求

1. **自动攻击触发**
   - 索敌系统检测到敌方目标时自动开始射击
   - 使用索敌系统选择的目标（按优先级）
   - 角色自动转向目标方向
   - 目标丢失后停止射击

2. **射击条件检查**
   - 目标必须是敌方阵营
   - 目标必须在射程范围内
   - 目标必须存活且可攻击（非无敌/隐身）
   - 步枪：角色必须静止
   - 冲锋枪：无移动限制

3. **射击逻辑**
   - 射击方向：自动朝向当前目标
   - 射击判定：服务端权威
   - 弹道表现：客户端预测 + 服务端校验
   - 命中反馈：即时显示

4. **移动限制**
   - 步枪：移动中自动停止射击，停止移动后恢复射击
   - 冲锋枪：移动中可以持续射击
   - 射击时根据枪械类型决定是否可以移动

5. **枪械切换**
   - 切换按钮位于屏幕右侧
   - 点击切换主副武器
   - 切换有动画时间（可配置）
   - 切换期间暂停自动射击
   - 切换完成后自动恢复射击（如果有目标）

#### 6.2.3 技术要求

**使用行为树（BT）实现**：

1. **为什么用 BT**
   - 射击流程复杂：检测目标 → 转向 → 射击 → 换弹
   - 需要处理多种条件：弹药、冷却、移动状态、Buff 状态
   - Buff 可以修改射击行为（眩晕禁止射击、加速提高射速）
   - BT 的条件节点和装饰节点非常适合这种场景

2. **BT 结构设计**
   ```
   自动射击 BT：
   ├── Repeat（循环执行）
   │   └── Sequence（顺序执行）
   │       ├── Condition: 检查是否有目标（索敌系统）
   │       ├── Condition: 检查弹药是否充足
   │       ├── Condition: 检查射击冷却
   │       ├── Condition: 检查移动状态（步枪专用）
   │       ├── Condition: 检查 Buff 状态（眩晕、沉默等）
   │       ├── Action: 转向目标
   │       ├── Action: 播放射击动画
   │       ├── Action: 发射弹道
   │       ├── Action: 扣除弹药
   │       └── Action: 触发射击冷却
   ```

3. **关键 BT 节点**
   - `CheckTargetNode`：检查索敌系统是否有目标
   - `CheckAmmoNode`：检查弹药是否充足
   - `CheckMovingNode`：检查是否移动中（步枪用）
   - `CheckBuffNode`：检查是否有禁止射击的 Buff
   - `TurnToTargetNode`：平滑转向目标
   - `FireBulletNode`：发射弹道，触发伤害判定

4. **Buff 与 BT 的交互**
   - Buff 修改 BT 条件节点的返回值
   - 例如：眩晕 Buff 让 `CheckBuffNode` 返回失败
   - 例如：加速 Buff 修改射击冷却时间参数
   - Buff 通过 `NumericComponent` 修改属性，BT 读取属性

5. **技术实现**
   - 依赖 `TargetSelectorComponent` 获取当前目标
   - 依赖 `CampComponent` 判断敌我关系
   - 使用 ET 框架的 `BehaviorTree` 系统（`cn.etetet.behaviortree` 包）
   - 枪械配置通过 Luban 配置表管理
   - 弹道使用射线检测或抛物线计算

### 6.3 射击与移动的交互

1. **步枪自动射击**
   - 移动中自动停止射击
   - 停止移动后自动恢复射击（如果有目标）
   - 角色朝向：移动时朝向移动方向，停止后朝向目标

2. **冲锋枪自动射击**
   - 可以边移动边射击
   - 移动速度不受影响（或略有降低，可配置）
   - 移动时射击精度下降（可配置）
   - 角色朝向：优先朝向目标，移动方向为辅

3. **朝向优先级**
   - 步枪：移动时朝向移动方向，停止时朝向目标
   - 冲锋枪：始终朝向目标（射击优先）
   - 无目标时：朝向移动方向或保持当前朝向

---

## 7. 输入优先级

当多个输入同时发生时的处理优先级：

1. **最高优先级**：枪械切换
2. **高优先级**：摇杆移动输入
3. **中优先级**：自动射击（后台自动执行）
4. **低优先级**：其他 UI 交互

规则：
- 自动射击在后台持续执行，不占用输入
- 步枪：移动时自动停止射击
- 冲锋枪：移动时继续射击
- 枪械切换期间，暂停自动射击和移动输入

---

## 8. 配置设计

### 8.1 移动配置

建议新增配置表：`JoystickMoveConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| SendIntervalMs | int | 客户端发送周期（毫秒，建议 50，即 20Hz） |
| ServerTickMs | int | 服务端 Tick 间隔（毫秒，建议 33，即 30Hz） |
| DirEpsilon | float | 方向变化阈值（建议 0.01） |
| InputTimeoutWarningMs | int | 输入超时警告（毫秒，建议 500） |
| InputTimeoutStopMs | int | 输入超时停止（毫秒，建议 1000） |
| SyncIntervalMs | int | 服务端广播周期（毫秒，建议 100） |
| MaxSpeedScale | float | 全局速度倍率（建议 1.0） |
| MaxMoveSpeed | float | 最大移动速度限制（m/s，建议 10.0） |
| SelfSnapDistanceHard | float | 自我回正硬阈值（米，建议 0.5） |
| SelfSnapDistanceSoft | float | 自我回正软阈值（米，建议 0.1） |
| NavMeshCheckDistance | float | NavMesh 回贴检查距离（米，建议 1.0） |
| TurnSpeed | float | 转向速度（度/秒，建议 360） |
| MinInputInterval | int | 最小输入间隔（毫秒，建议 40，防刷） |

**配置说明**：
- 服务端 Tick 频率：30Hz（12 人同屏可以更高）
- 客户端发送频率：20Hz（无需过高，避免浪费带宽）
- 超时分级：0.5 秒开始减速，1.0 秒完全停止
- NavMesh 回贴距离：移动 1 米后才重新查询，减少性能开销

### 8.2 相机配置

**参考现有实现**：`Packages/cn.etetet.map/Scripts/HotfixView/Client/CinemachineComponentSystem.cs`

当前项目使用 Cinemachine 实现相机系统，建议扩展现有配置：

建议新增配置表：`CameraConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| CameraMode | int | 相机模式（0=固定俯视，1=自由视角，2=跟随） |
| FollowTarget | string | 跟随目标（Head/Body/Custom） |
| FollowDamping | float | 跟随阻尼（平滑度，建议 1.0-5.0） |
| LookAtOffset | Vector3 | 注视点偏移（相对于跟随目标） |
| CameraDistance | float | 相机距离（米，建议 5-15） |
| CameraHeight | float | 相机高度（米，建议 3-10） |
| CameraAngle | float | 俯视角度（度，建议 30-60） |
| FOV | float | 视野范围（度，建议 40-60） |
| MinAngleX | float | 最小俯仰角（度，当前 10） |
| MaxAngleX | float | 最大俯仰角（度，当前 80） |
| EnableRotation | bool | 是否允许旋转相机 |
| RotationSensitivity | float | 旋转灵敏度（当前 1/5） |
| EnableCollision | bool | 是否启用碰撞检测 |
| SceneId | int | 场景 ID（不同场景可用不同配置） |

**当前实现特点**：
- 使用 `CinemachineVirtualCamera` 实现
- 跟随目标：角色头部（Head BindPoint）
- 创建独立的 Follow Transform 用于相机跟随
- 支持相机旋转（`RotationFollow` 方法）
- 俯仰角限制：10-80 度

**俯视角固定相机改造建议**：
1. 保留现有 `CinemachineComponent` 结构
2. 新增 `CameraMode` 字段区分模式
3. 固定俯视模式：
   - 禁用 `RotationFollow` 方法
   - 设置固定的 Follow Transform 角度
   - 锁定相机距离和高度
4. 配置通过 Luban 配置表管理

### 8.3 枪械配置

建议新增配置表：`WeaponConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| WeaponId | int | 枪械 ID |
| WeaponName | string | 枪械名称 |
| WeaponType | int | 枪械类型（0=步枪，1=冲锋枪，2=狙击枪，3=霰弹枪） |
| Damage | int | 伤害值 |
| FireRate | float | 射速（发/秒） |
| Range | float | 射程（米） |
| MagazineSize | int | 弹匣容量 |
| ReloadTime | float | 换弹时间（秒） |
| CanMoveWhileFire | bool | 射击时是否可移动 |
| MoveSpeedScale | float | 移动时速度倍率（1.0=不变，0.8=降低 20%） |
| AccuracyWhileMove | float | 移动时精度倍率（1.0=不变，0.7=降低 30%） |
| AttackRange | float | 射程（米） |
| AutoAttackInterval | float | 自动攻击间隔（秒） |
| TargetSwitchCooldown | float | 目标切换冷却（秒） |
| SwitchTime | float | 切换到此武器的时间（秒） |

### 8.4 阵营配置

建议新增配置表：`CampConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| CampId | int | 阵营 ID |
| CampName | string | 阵营名称 |
| CampColor | string | 阵营颜色（十六进制，如 "#FF0000"） |
| FriendlyCamps | int[] | 友方阵营 ID 列表 |
| EnemyCamps | int[] | 敌方阵营 ID 列表 |

### 8.5 索敌配置

建议新增配置表：`TargetSelectorConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| DetectInterval | int | 检测间隔（毫秒，建议 100-200） |
| TargetLostDelay | int | 目标丢失延迟（毫秒，建议 500） |
| SwitchCooldown | int | 目标切换冷却（毫秒，建议 1000） |
| EnableLineOfSight | bool | 是否启用视野检测 |
| PriorityAttackingMe | int | 正在攻击自己的目标优先级（建议 100） |
| PriorityPlayer | int | 玩家目标优先级（建议 80） |
| PriorityElite | int | 精英怪优先级（建议 60） |
| PriorityNormal | int | 普通怪优先级（建议 40） |

### 8.6 局外装备配置

建议新增配置表：`PlayerLoadoutConfig`

| 字段名 | 类型 | 说明 |
|--------|------|------|
| PlayerId | long | 玩家 ID |
| PrimaryWeaponId | int | 主武器 ID |
| SecondaryWeaponId | int | 副武器 ID |

---

## 8. 非功能需求

### 8.1 性能要求

1. **帧率**
   - 客户端渲染帧率 ≥ 30 FPS（目标 60 FPS）
   - 移动输入响应延迟 < 50ms
   - 技能释放响应延迟 < 100ms

2. **网络**
   - 摇杆输入上报频率：20Hz
   - 服务端同步广播频率：10-20Hz
   - 单个玩家移动带宽 < 5KB/s

3. **内存**
   - 弹道特效对象池管理
   - 相机组件轻量化

### 8.2 兼容性要求

1. 支持不同分辨率和屏幕比例
2. 支持不同性能设备（低中高配置）
3. 与现有 ECS 架构兼容
4. 与现有网络同步系统兼容

### 8.3 可扩展性要求

1. 支持后续添加新的枪械类型
2. 支持后续添加相机特效（震动、缩放等）
3. 支持后续添加更多输入方式（键盘、手柄）
4. 支持后续添加枪械配件系统（瞄准镜、弹匣等）

---

## 9. 行为树（BT）技术方案

### 9.1 为什么使用行为树

**技能和枪械都应该使用 BT 实现**，原因如下：

1. **复杂的执行流程**
   - 技能：前摇 → 施法 → 后摇 → 冷却
   - 枪械：检测目标 → 转向 → 射击 → 换弹
   - 流程中有多个条件判断和状态转换

2. **条件判断清晰**
   - 冷却时间、资源消耗、距离检测
   - 移动状态、目标状态、Buff 状态
   - BT 的条件节点天然适合这些判断

3. **Buff 系统集成**
   - Buff 可以修改 BT 节点的行为
   - 眩晕：让条件节点返回失败
   - 加速：修改动作节点的参数
   - 沉默：禁用特定技能分支

4. **可视化和调试**
   - BT 可以可视化编辑（如果有编辑器）
   - 运行时可以看到当前执行的节点
   - 方便调试和优化

### 9.2 枪械 BT 设计

#### 9.2.1 步枪 BT 结构

```
步枪自动射击 BT：
Root
└── Repeat（无限循环）
    └── Sequence（顺序执行，任一失败则停止）
        ├── Condition: 检查是否有目标
        │   └── 调用 TargetSelectorComponent.GetCurrentTarget()
        ├── Condition: 检查弹药
        │   └── 检查 MagazineSize > 0
        ├── Condition: 检查射击冷却
        │   └── 检查 Time.Now - LastFireTime > FireInterval
        ├── Condition: 检查是否静止（步枪专用）
        │   └── 检查 MoveComponent.IsMoving == false
        ├── Condition: 检查 Buff 状态
        │   └── 检查是否有眩晕、沉默等禁止射击的 Buff
        ├── Action: 转向目标
        │   └── 平滑旋转朝向目标
        ├── Action: 播放射击动画
        ├── Action: 发射弹道
        │   └── 创建子弹实体，计算弹道
        ├── Action: 扣除弹药
        │   └── MagazineSize -= 1
        ├── Action: 触发射击冷却
        │   └── LastFireTime = Time.Now
        └── Wait: 等待射击间隔
            └── 等待 FireInterval 毫秒
```

#### 9.2.2 冲锋枪 BT 结构

```
冲锋枪自动射击 BT：
Root
└── Repeat（无限循环）
    └── Sequence（顺序执行）
        ├── Condition: 检查是否有目标
        ├── Condition: 检查弹药
        ├── Condition: 检查射击冷却
        ├── Condition: 检查 Buff 状态
        │   （注意：没有检查移动状态，冲锋枪可以移动射击）
        ├── Action: 转向目标
        ├── Action: 播放射击动画
        ├── Action: 发射弹道
        │   └── 如果移动中，精度降低（配置表控制）
        ├── Action: 扣除弹药
        ├── Action: 触发射击冷却
        └── Wait: 等待射击间隔
```

#### 9.2.3 换弹 BT 结构

```
换弹 BT（作为子树或并行节点）：
Sequence
├── Condition: 检查弹药为空
│   └── MagazineSize == 0
├── Condition: 检查备弹充足
│   └── ReserveAmmo > 0
├── Action: 播放换弹动画
├── Wait: 等待换弹时间
│   └── 等待 ReloadTime 秒
└── Action: 填充弹药
    └── MagazineSize = MaxMagazineSize
    └── ReserveAmmo -= MaxMagazineSize
```

### 9.3 关键 BT 节点实现

#### 9.3.1 条件节点

```csharp
// 检查目标节点
public class CheckTargetNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();
        TargetSelectorComponent selector = unit.GetComponent<TargetSelectorComponent>();

        if (selector.CurrentTarget != null && !selector.CurrentTarget.IsDisposed)
        {
            return BTStatus.Success;
        }

        return BTStatus.Failure;
    }
}

// 检查移动状态节点（步枪专用）
public class CheckNotMovingNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();
        MoveComponent move = unit.GetComponent<MoveComponent>();

        if (move == null || !move.IsMoving())
        {
            return BTStatus.Success;
        }

        return BTStatus.Failure;
    }
}

// 检查 Buff 状态节点
public class CheckCanFireNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();

        // 检查是否有禁止射击的 Buff
        if (unit.HasBuff(BuffType.Stun) ||
            unit.HasBuff(BuffType.Silence) ||
            unit.HasBuff(BuffType.Disarm))
        {
            return BTStatus.Failure;
        }

        return BTStatus.Success;
    }
}
```

#### 9.3.2 动作节点

```csharp
// 转向目标节点
public class TurnToTargetNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();
        TargetSelectorComponent selector = unit.GetComponent<TargetSelectorComponent>();

        if (selector.CurrentTarget == null)
        {
            return BTStatus.Failure;
        }

        // 平滑转向目标
        float3 direction = selector.CurrentTarget.Position - unit.Position;
        direction.y = 0;

        if (math.lengthsq(direction) > 0.01f)
        {
            quaternion targetRotation = quaternion.LookRotation(direction, math.up());
            unit.Rotation = math.slerp(unit.Rotation, targetRotation, 0.2f);
        }

        return BTStatus.Success;
    }
}

// 发射弹道节点
public class FireBulletNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weapon = unit.GetComponent<WeaponComponent>();
        TargetSelectorComponent selector = unit.GetComponent<TargetSelectorComponent>();

        if (selector.CurrentTarget == null)
        {
            return BTStatus.Failure;
        }

        // 创建子弹实体
        Unit bullet = UnitFactory.CreateBullet(unit.Scene(), weapon.WeaponConfig);
        bullet.Position = unit.Position + new float3(0, 1.5f, 0); // 枪口位置

        // 计算弹道方向
        float3 direction = selector.CurrentTarget.Position - bullet.Position;
        bullet.Forward = math.normalize(direction);

        // 扣除弹药
        weapon.MagazineSize -= 1;

        return BTStatus.Success;
    }
}
```

### 9.4 Buff 与 BT 的交互

#### 9.4.1 Buff 影响 BT 执行

```csharp
// Buff 通过修改 NumericComponent 影响 BT
public class AttackSpeedBuff : Buff
{
    protected override void OnAdd()
    {
        // 提高攻速 = 降低射击间隔
        Unit unit = this.GetParent<Unit>();
        unit.NumericComponent.Set(NumericType.AttackSpeed, 1.5f); // 提高 50%
    }

    protected override void OnRemove()
    {
        Unit unit = this.GetParent<Unit>();
        unit.NumericComponent.Set(NumericType.AttackSpeed, 1.0f); // 恢复正常
    }
}

// BT 节点读取 NumericComponent
public class WaitFireIntervalNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();
        WeaponComponent weapon = unit.GetComponent<WeaponComponent>();

        // 读取攻速属性
        float attackSpeed = unit.NumericComponent.GetAsFloat(NumericType.AttackSpeed);
        float interval = weapon.FireInterval / attackSpeed; // Buff 影响间隔

        // 等待间隔
        if (Time.Now - weapon.LastFireTime >= interval)
        {
            return BTStatus.Success;
        }

        return BTStatus.Running;
    }
}
```

#### 9.4.2 Buff 禁用 BT 分支

```csharp
// 眩晕 Buff 让条件节点失败
public class StunBuff : Buff
{
    // Buff 本身不需要做什么，只需要存在即可
}

// BT 节点检查 Buff
public class CheckCanFireNode : BTNode
{
    protected override BTStatus OnExecute(BTContext context)
    {
        Unit unit = context.GetUnit();

        // 有眩晕 Buff 就不能射击
        if (unit.HasBuff(BuffType.Stun))
        {
            return BTStatus.Failure; // 整个射击流程停止
        }

        return BTStatus.Success;
    }
}
```

### 9.5 BT 配置化

**建议：每把枪械配置一个独立的 BT**

#### 9.5.1 为什么每把枪一个 BT

1. **行为差异大**
   - 步枪：需要检查移动状态
   - 冲锋枪：不检查移动状态
   - 狙击枪：需要瞄准时间
   - 霰弹枪：近距离散射

2. **灵活性高**
   - 每把枪可以有完全不同的射击流程
   - 后续添加新枪械只需新增 BT 配置
   - 不需要在 BT 中写大量 if-else

3. **可维护性好**
   - BT 逻辑清晰，易于理解
   - 修改一把枪不影响其他枪
   - 配置文件独立，便于管理

#### 9.5.2 配置结构

```json
// WeaponConfig.json
{
    "WeaponId": 1001,
    "WeaponName": "步枪",
    "WeaponType": 0,
    "Damage": 50,
    "FireRate": 2.0,
    "Range": 20.0,
    "BTConfigId": 10001  // 指向 BT 配置
}

{
    "WeaponId": 1002,
    "WeaponName": "冲锋枪",
    "WeaponType": 1,
    "Damage": 30,
    "FireRate": 5.0,
    "Range": 15.0,
    "BTConfigId": 10002  // 不同的 BT 配置
}
```

```json
// BTConfig_10001.json (步枪)
{
    "BTId": 10001,
    "BTName": "步枪射击 BT",
    "RootNode": {
        "NodeType": "Repeat",
        "Children": [
            {
                "NodeType": "Sequence",
                "Children": [
                    { "NodeType": "CheckTarget" },
                    { "NodeType": "CheckAmmo" },
                    { "NodeType": "CheckCooldown" },
                    { "NodeType": "CheckNotMoving" },  // 步枪特有
                    { "NodeType": "CheckCanFire" },
                    { "NodeType": "TurnToTarget" },
                    { "NodeType": "PlayAnimation", "AnimName": "Fire" },
                    { "NodeType": "FireBullet" },
                    { "NodeType": "ConsumeAmmo" },
                    { "NodeType": "TriggerCooldown" },
                    { "NodeType": "Wait", "Duration": 0.5 }
                ]
            }
        ]
    }
}

// BTConfig_10002.json (冲锋枪)
{
    "BTId": 10002,
    "BTName": "冲锋枪射击 BT",
    "RootNode": {
        "NodeType": "Repeat",
        "Children": [
            {
                "NodeType": "Sequence",
                "Children": [
                    { "NodeType": "CheckTarget" },
                    { "NodeType": "CheckAmmo" },
                    { "NodeType": "CheckCooldown" },
                    // 没有 CheckNotMoving，冲锋枪可以移动射击
                    { "NodeType": "CheckCanFire" },
                    { "NodeType": "TurnToTarget" },
                    { "NodeType": "PlayAnimation", "AnimName": "Fire" },
                    { "NodeType": "FireBullet" },
                    { "NodeType": "ConsumeAmmo" },
                    { "NodeType": "TriggerCooldown" },
                    { "NodeType": "Wait", "Duration": 0.2 }
                ]
            }
        ]
    }
}
```

#### 9.5.3 BT 加载流程

```csharp
// 装备枪械时加载对应的 BT
public static void EquipWeapon(this Unit unit, int weaponId)
{
    // 1. 获取枪械配置
    WeaponConfig config = WeaponConfigCategory.Instance.Get(weaponId);

    // 2. 创建枪械组件
    WeaponComponent weapon = unit.AddComponent<WeaponComponent>();
    weapon.WeaponConfig = config;

    // 3. 加载对应的 BT
    BTConfig btConfig = BTConfigCategory.Instance.Get(config.BTConfigId);
    weapon.BehaviorTree = BTFactory.Create(btConfig);

    // 4. 启动 BT
    weapon.BehaviorTree.Start();
}

// 切换枪械时切换 BT
public static void SwitchWeapon(this Unit unit)
{
    WeaponComponent weapon = unit.GetComponent<WeaponComponent>();

    // 1. 停止当前 BT
    weapon.BehaviorTree?.Stop();

    // 2. 切换到另一把枪
    int newWeaponId = weapon.IsUsingPrimary ? weapon.SecondaryWeaponId : weapon.PrimaryWeaponId;

    // 3. 加载新枪的 BT
    WeaponConfig config = WeaponConfigCategory.Instance.Get(newWeaponId);
    BTConfig btConfig = BTConfigCategory.Instance.Get(config.BTConfigId);
    weapon.BehaviorTree = BTFactory.Create(btConfig);

    // 4. 启动新 BT
    weapon.BehaviorTree.Start();
}
```

#### 9.5.4 节点复用

虽然每把枪有独立的 BT 配置，但**节点代码是复用的**：

```csharp
// 所有枪械共享这些节点类
public class CheckTargetNode : BTNode { ... }
public class CheckAmmoNode : BTNode { ... }
public class CheckNotMovingNode : BTNode { ... }
public class TurnToTargetNode : BTNode { ... }
public class FireBulletNode : BTNode { ... }

// 只是配置文件中组合方式不同
// 步枪 BT：包含 CheckNotMovingNode
// 冲锋枪 BT：不包含 CheckNotMovingNode
```

**优点**：
- 代码复用，不重复开发
- 配置灵活，组合方式自由
- 易于扩展，添加新节点即可

### 9.6 实施建议

1. **复用 ET 框架的 BT 系统**
   - 使用 `cn.etetet.behaviortree` 包
   - 参考现有的 AI 行为树实现

2. **先实现基础节点**
   - 条件节点：CheckTarget, CheckAmmo, CheckCooldown
   - 动作节点：TurnToTarget, FireBullet, ConsumeAmmo
   - 控制节点：Sequence, Repeat, Wait

3. **逐步扩展**
   - 先实现步枪的简单 BT
   - 再实现冲锋枪（去掉移动检查）
   - 最后添加换弹、Buff 交互等复杂功能

4. **测试和调试**
   - 使用 BT 可视化工具（如果有）
   - 添加日志输出当前执行的节点
   - 编写单元测试验证各个节点

---

## 10. 实施优先级

### 10.1 P0（必须实现）

1. 摇杆移动基础功能（固定速度）
2. 固定俯视角相机跟随
3. 阵营系统（单人模式，每人独立阵营）
4. 索敌系统（基础目标选择）
5. 基础 BT 节点（条件、动作、控制）
6. 步枪 BT 实现（自动射击）
7. 基础枪械（步枪、冲锋枪）
8. 局外装备系统（双枪械）

### 10.2 P1（重要）

1. 组队模式（队伍阵营）
2. 目标优先级系统
3. 目标切换冷却
4. 手动切换目标（UI 按钮）
5. 冲锋枪 BT 实现
6. 换弹 BT 实现
7. 基础 Buff 系统（眩晕、加速）
8. Buff 与 BT 交互
9. 枪械切换功能
10. 弹药系统和换弹
11. 相机平滑跟随

### 10.3 P2（可选）

1. 多阵营模式（红蓝对抗）
2. 视野遮挡检测
3. BT 配置化（JSON 配置）
4. BT 可视化编辑器
5. 更多 Buff 类型（沉默、缴械、减速）
6. 更多枪械类型（狙击枪、霰弹枪）
7. 射击精度系统
8. 相机碰撞检测
9. 枪械配件系统

---

## 10. 验收标准

### 10.1 移动操作

- [ ] 摇杆推动时角色持续移动
- [ ] 松开摇杆时角色立即停止
- [ ] 移动方向与摇杆方向一致
- [ ] 移动速度固定（不受摇杆偏移量影响）
- [ ] 角色朝向平滑转向（移动方向或目标方向）
- [ ] 不发生穿墙或卡地形
- [ ] 多人同屏移动同步正常

### 10.2 相机操作

- [ ] 相机以固定角度俯视场景
- [ ] 相机平滑跟随玩家角色
- [ ] 相机不可旋转、缩放、拖拽
- [ ] 场景边界时相机行为正常
- [ ] 不同场景可使用不同相机配置

### 10.3 阵营系统

- [ ] 玩家进入地图时正确分配阵营
- [ ] 同阵营玩家不可互相攻击
- [ ] 不同阵营玩家可以互相攻击
- [ ] 阵营颜色显示正确（友方绿色，敌方红色）
- [ ] 组队模式下队友为同阵营

### 11.4 索敌系统

- [ ] 正确检测射程范围内的敌方目标
- [ ] 按优先级选择目标（攻击自己的 > 玩家 > 精英 > 普通）
- [ ] 目标死亡时自动切换
- [ ] 目标离开射程时正确处理
- [ ] 目标切换冷却功能正常
- [ ] 手动切换目标按钮功能正常
- [ ] 手动切换无冷却限制
- [ ] 只有一个目标时按钮置灰

### 11.5 自动射击系统

- [ ] 检测到敌方目标时自动开始射击
- [ ] 只攻击敌方阵营目标
- [ ] 角色自动转向目标方向
- [ ] 步枪 BT 正确执行（移动时停止射击）
- [ ] 冲锋枪 BT 正确执行（可以边移动边射击）
- [ ] 换弹 BT 正确执行
- [ ] Buff 可以影响射击行为（眩晕、加速）
- [ ] 枪械切换功能正常
- [ ] 弹药显示和换弹功能正常
- [ ] 局外装备的枪械正确带入地图
- [ ] 目标丢失后停止射击

### 10.4 整体体验

- [ ] 操作响应流畅，无明显延迟
- [ ] 客户端帧率稳定
- [ ] 网络同步正常，无明显漂移
- [ ] 无明显 Bug 和异常

---

## 11. 风险与规避

### 11.1 技术风险

1. **风险**：摇杆移动与现有点击移动冲突
   - **规避**：统一到 MoveComponent，使用 MoveMode 区分模式

2. **风险**：频繁网络同步导致带宽上涨
   - **规避**：方向变化才发输入 + 服务端固定频率同步 + 仅在变化时广播

3. **风险**：客户端位置抖动
   - **规避**：客户端预测 + 误差阈值分级回正（硬对齐/平滑插值/信任预测）

4. **风险**：射击判定不准确
   - **规避**：服务端权威判定 + 客户端预测表现

5. **风险**：NavMesh 回贴性能问题
   - **规避**：条件回贴（移动 1 米后才查询）+ 考虑异步回贴

6. **风险**：输入序列号溢出
   - **规避**：使用循环比较处理 Seq 溢出

7. **风险**：外挂作弊（超速移动、瞬移）
   - **规避**：服务端速度限制 + 异常移动检测 + 输入频率限制

8. **风险**：网络断开后"幽灵前进"
   - **规避**：输入超时自动停止（1 秒）

### 11.2 设计风险

1. **风险**：固定相机视野受限
   - **规避**：优化相机参数，确保足够视野范围

2. **风险**：步枪移动限制影响手感
   - **规避**：提供清晰的 UI 反馈，移动时禁用射击按钮

---

## 12. 参考文档

1. `MyBook/说明文档/9.3摇杆移动改造实施文档.md` - 摇杆移动技术方案
2. `MyBook/需求文档/摇杆移动方案评估报告.md` - 摇杆移动方案评估
3. `Packages/cn.etetet.move/` - 现有移动系统
4. `Packages/cn.etetet.spell/` - 现有技能系统
5. `Packages/cn.etetet.item/` - 现有道具系统（可用于枪械装备）
6. `Packages/cn.etetet.behaviortree/` - 现有行为树系统
7. `AGENTS.md` - ET 框架架构规范

---

## 16. 后续工作

完成本需求文档后，需要进行：

1. 技术方案设计（详细设计文档）
2. 原型开发和验证
3. 正式开发实施
4. 测试和优化
5. 文档更新和维护

---

## 17. 附录 A：术语表

- **摇杆**：虚拟摇杆，屏幕触摸输入控件
- **俯视角**：从上方向下观察的相机角度
- **步枪**：只能在静止时射击的枪械类型
- **冲锋枪**：可以边移动边射击的枪械类型
- **局外装备**：在进入地图前装备的物品（枪械）
- **主武器/副武器**：玩家携带的两把枪械
- **阵营**：玩家所属的队伍/派系，决定敌我关系
- **索敌**：自动检测和选择攻击目标的系统
- **目标优先级**：不同类型目标的攻击优先顺序
- **NavMesh**：导航网格，用于寻路和碰撞检测
- **竖屏**：手机竖向持握的屏幕方向
- **行为树（BT）**：Behavior Tree，用于实现复杂的逻辑流程
- **BT 节点**：行为树的基本单元（条件节点、动作节点、控制节点）
- **Buff**：增益/减益效果，可以修改角色属性或行为
- **NumericComponent**：数值组件，管理角色的各种属性

---

## 18. 附录 B：UI 布局建议（竖屏）

```
┌───────────────┐
│   [血条/UI]   │
│               │
│               │
│               │
│   游戏画面     │
│   (自动射击)  │
│               │
│               │
│               │
│               │
│               │
│ [摇杆]  [切目]│
│         [切枪]│
│         [弹药]│
└───────────────┘
```

- 左下角：虚拟摇杆（移动控制）
- 右下角：切换目标按钮（手动切换）
- 右下角：枪械切换按钮
- 右下角：弹药显示
- 顶部：血条、小地图等信息 UI
- 无射击按钮：自动攻击射程内目标

**竖屏特点**：
- 单手操作友好（左手摇杆，右手切换目标/枪械）
- 视野纵向更长，适合俯视角
- UI 布局简洁，不遮挡视野
- 自动射击减少操作负担
- 手动切换目标提供战术选择

---

---

## 19. 附录 C：枪械系统设计要点

### C.1 枪械类型对比

| 枪械类型 | 移动射击 | 射速 | 伤害 | 射程 | 适用场景 |
|---------|---------|------|------|------|---------|
| 步枪 | ❌ 禁止 | 中等 | 高 | 远 | 定点输出 |
| 冲锋枪 | ✅ 允许 | 快 | 中 | 中 | 机动作战 |
| 狙击枪 | ❌ 禁止 | 慢 | 极高 | 极远 | 远程狙击 |
| 霰弹枪 | ✅ 允许 | 慢 | 高（近距离） | 近 | 近战突进 |

### C.2 局外装备流程

1. **局外界面**：玩家选择 2 把枪械装备
2. **保存配置**：装备配置保存到数据库
3. **进入地图**：读取装备配置，创建枪械实体
4. **局内使用**：玩家可切换使用两把枪械
5. **局外修改**：退出地图后可重新装备

### C.3 技术实现建议

1. **枪械实体**：使用 `ItemComponent` 管理枪械（复用道具系统）
2. **射击判定**：使用 `SpellComponent` 实现射击技能
3. **移动限制**：在 `MoveComponent` 中检查当前枪械类型
4. **装备同步**：进入地图时从服务端同步装备配置

---

**文档版本**：v2.0
**创建日期**：2026-03-01
**最后更新**：2026-03-01
**更新内容**：改为竖屏双枪械射击系统，去除复杂技能指示器
**文档状态**：待评审
