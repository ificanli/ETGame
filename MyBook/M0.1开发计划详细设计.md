# M0.1 开发计划详细设计

## 版本信息

- **里程碑**: M0.1 框架搭建
- **时间**: 第1-4周
- **优先级**: P0
- **目标**: 建立核心系统框架，跑通完整流程管线

## 验收标准

- ✅ 能够匹配进入战局
- ✅ 使用现有点击移动+技能系统进行战斗
- ✅ 死亡或撤离后能正常结算并返回大厅
- ✅ 支持多人 PVP 同局

---

## 包结构设计

### 新增包

#### 1. cn.etetet.match（匹配系统）- 第2层

**依赖关系**:
- 依赖: `cn.etetet.core`, `cn.etetet.proto`
- 被依赖: `cn.etetet.battle`

**目录结构**:
```
cn.etetet.match/
├── Scripts/
│   ├── Model/
│   │   └── Share/
│   │       ├── PackageType.cs
│   │       ├── MatchQueueComponent.cs
│   │       ├── MatchRequestComponent.cs
│   │       └── MatchResultComponent.cs
│   └── Hotfix/
│       ├── Server/
│       │   ├── MatchQueueComponentSystem.cs
│       │   ├── MatchRequestComponentSystem.cs
│       │   └── MatchHelper.cs
│       └── Test/
│           └── Match_BasicFlow_Test.cs
├── packagegit.json
└── AGENTS.md
```

#### 2. cn.etetet.battle（战局系统）- 第3层

**依赖关系**:
- 依赖: `cn.etetet.core`, `cn.etetet.proto`, `cn.etetet.match`, `cn.etetet.unit`, `cn.etetet.map`
- 被依赖: 上层业务包

**目录结构**:
```
cn.etetet.battle/
├── Scripts/
│   ├── Model/
│   │   └── Share/
│   │       ├── PackageType.cs
│   │       ├── BattleSessionComponent.cs
│   │       ├── BattleStateComponent.cs
│   │       ├── SettlementComponent.cs
│   │       └── InteractableComponent.cs
│   └── Hotfix/
│       ├── Server/
│       │   ├── BattleSessionComponentSystem.cs
│       │   ├── BattleStateComponentSystem.cs
│       │   ├── SettlementComponentSystem.cs
│       │   ├── InteractableComponentSystem.cs
│       │   └── BattleHelper.cs
│       └── Test/
│           ├── Battle_StateFlow_Test.cs
│           ├── Battle_Settlement_Test.cs
│           └── Battle_Interactable_Test.cs
├── packagegit.json
└── AGENTS.md
```

---

## 第1周：匹配系统

### 目标
实现基础的匹配队列和地图分配，支持多种游戏模式

### TDD 流程

#### 步骤1: 需求分析和文档设计
创建 `cn.etetet.match/Test.md`，包含：
- 匹配流程说明
- 支持的游戏模式（PVE、1v1、3v3、搜打撤）
- 匹配成功后的地图分配逻辑
- 测试场景设计

#### 步骤2: Entity 设计

**MatchQueueComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 匹配队列组件
    /// 管理所有等待匹配的玩家请求
    /// </summary>
    [ComponentOf(typeof(Scene))]
    public class MatchQueueComponent : Entity, IAwake, IDestroy
    {
        /// <summary>
        /// 游戏模式 -> 匹配请求列表
        /// </summary>
        public Dictionary<int, List<EntityRef<MatchRequestComponent>>> QueueDict;

        /// <summary>
        /// 匹配超时时间（毫秒）
        /// </summary>
        public long MatchTimeout;
    }
}
```

**MatchRequestComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 匹配请求组件
    /// 表示一个玩家的匹配请求
    /// </summary>
    [ComponentOf(typeof(Scene))]
    public class MatchRequestComponent : Entity, IAwake<long, int>, IDestroy
    {
        /// <summary>
        /// 玩家ID
        /// </summary>
        public long PlayerId;

        /// <summary>
        /// 游戏模式（1=PVE, 2=1v1, 3=3v3, 4=搜打撤）
        /// </summary>
        public int GameMode;

        /// <summary>
        /// 请求时间戳
        /// </summary>
        public long RequestTime;

        /// <summary>
        /// 匹配状态（0=等待中, 1=匹配成功, 2=超时）
        /// </summary>
        public int Status;
    }
}
```

**MatchResultComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 匹配结果组件
    /// 存储匹配成功后的信息
    /// </summary>
    [ComponentOf(typeof(Scene))]
    public class MatchResultComponent : Entity, IAwake, IDestroy
    {
        /// <summary>
        /// 战局ID
        /// </summary>
        public long BattleSessionId;

        /// <summary>
        /// 分配的地图名称
        /// </summary>
        public string MapName;

        /// <summary>
        /// 参与玩家ID列表
        /// </summary>
        public List<long> PlayerIds;

        /// <summary>
        /// 游戏模式
        /// </summary>
        public int GameMode;
    }
}
```

#### 步骤3: System 设计

**MatchQueueComponentSystem.cs** (Hotfix/Server)
```csharp
namespace ET.Server
{
    [EntitySystemOf(typeof(MatchQueueComponent))]
    public static partial class MatchQueueComponentSystem
    {
        [EntitySystem]
        private static void Awake(this MatchQueueComponent self)
        {
            self.QueueDict = new Dictionary<int, List<EntityRef<MatchRequestComponent>>>();
            self.MatchTimeout = 30000; // 30秒超时
        }

        [EntitySystem]
        private static void Destroy(this MatchQueueComponent self)
        {
            self.QueueDict.Clear();
        }

        /// <summary>
        /// 添加匹配请求到队列
        /// </summary>
        public static void AddRequest(this MatchQueueComponent self, MatchRequestComponent request)
        {
            // 实现逻辑
        }

        /// <summary>
        /// 尝试匹配玩家
        /// </summary>
        public static MatchResultComponent TryMatch(this MatchQueueComponent self, int gameMode)
        {
            // 实现逻辑
            return null;
        }

        /// <summary>
        /// 移除超时的匹配请求
        /// </summary>
        public static void RemoveTimeoutRequests(this MatchQueueComponent self)
        {
            // 实现逻辑
        }
    }
}
```

**MatchHelper.cs** (Hotfix/Server)
```csharp
namespace ET.Server
{
    /// <summary>
    /// 匹配系统辅助类
    /// 处理匹配相关的业务逻辑
    /// </summary>
    public static class MatchHelper
    {
        /// <summary>
        /// 根据游戏模式获取需要的玩家数量
        /// </summary>
        public static int GetRequiredPlayerCount(int gameMode)
        {
            // 1=PVE(1人), 2=1v1(2人), 3=3v3(6人), 4=搜打撤(可变)
            return gameMode switch
            {
                1 => 1,
                2 => 2,
                3 => 6,
                4 => 1, // 搜打撤可以单人或多人
                _ => 1
            };
        }

        /// <summary>
        /// 分配地图
        /// </summary>
        public static string AllocateMap(int gameMode)
        {
            // 根据游戏模式分配地图
            return "DefaultMap";
        }
    }
}
```

#### 步骤4: 测试用例设计

**Match_BasicFlow_Test.cs** (Hotfix/Test)
```csharp
namespace ET.Server
{
    /// <summary>
    /// 测试匹配基础流程
    /// </summary>
    [Test]
    public class Match_BasicFlow_Test : ATestHandler
    {
        protected override async ETTask<int> Run(Fiber fiber, TestArgs args)
        {
            // 1. 创建匹配队列
            Scene scene = fiber.Root.CurrentScene();
            MatchQueueComponent queue = scene.AddComponent<MatchQueueComponent>();

            if (queue == null)
            {
                Log.Console("Failed to create MatchQueueComponent");
                return 1;
            }

            // 2. 创建匹配请求（1v1模式）
            MatchRequestComponent request1 = scene.AddComponent<MatchRequestComponent, long, int>(1001, 2);
            MatchRequestComponent request2 = scene.AddComponent<MatchRequestComponent, long, int>(1002, 2);

            queue.AddRequest(request1);
            queue.AddRequest(request2);

            // 3. 尝试匹配
            MatchResultComponent result = queue.TryMatch(2);

            if (result == null)
            {
                Log.Console("Match failed");
                return 2;
            }

            // 4. 验证匹配结果
            if (result.PlayerIds.Count != 2)
            {
                Log.Console($"Player count error, expected: 2, actual: {result.PlayerIds.Count}");
                return 3;
            }

            if (result.GameMode != 2)
            {
                Log.Console($"Game mode error, expected: 2, actual: {result.GameMode}");
                return 4;
            }

            Log.Debug("Match basic flow test passed");
            return ErrorCode.ERR_Success;
        }
    }
}
```

#### 步骤5: 开发检查清单

- [ ] 创建 cn.etetet.match 包
- [ ] 配置 packagegit.json（PackageType ID）
- [ ] 创建 PackageType.cs
- [ ] 实现所有 Entity 类
- [ ] 实现所有 System 类
- [ ] 实现 MatchHelper 业务逻辑
- [ ] 编写测试用例
- [ ] 编译验证（`dotnet build ET.sln`）
- [ ] 运行测试验证
- [ ] 编写 AGENTS.md 文档

---

## 第2周：战局状态机

### 目标
实现战局生命周期管理，包括准备、战斗、结算三个阶段

### TDD 流程

#### 步骤1: 需求分析和文档设计
创建 `cn.etetet.battle/Test.md`，包含：
- 战局状态流转图
- 死亡判定逻辑
- 撤离判定逻辑
- 战局结束条件

#### 步骤2: Entity 设计

**BattleSessionComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 战局会话组件
    /// 管理一场战斗的完整生命周期
    /// </summary>
    [ComponentOf(typeof(Scene))]
    public class BattleSessionComponent : Entity, IAwake<long, int>, IDestroy
    {
        /// <summary>
        /// 战局ID
        /// </summary>
        public long SessionId;

        /// <summary>
        /// 游戏模式
        /// </summary>
        public int GameMode;

        /// <summary>
        /// 参与玩家ID列表
        /// </summary>
        public List<long> PlayerIds;

        /// <summary>
        /// 地图名称
        /// </summary>
        public string MapName;

        /// <summary>
        /// 创建时间
        /// </summary>
        public long CreateTime;

        /// <summary>
        /// 战局开始时间
        /// </summary>
        public long StartTime;

        /// <summary>
        /// 战局结束时间
        /// </summary>
        public long EndTime;
    }
}
```

**BattleStateComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 战局状态组件
    /// 管理战局的当前状态
    /// </summary>
    [ComponentOf(typeof(BattleSessionComponent))]
    public class BattleStateComponent : Entity, IAwake, IDestroy, IUpdate
    {
        /// <summary>
        /// 当前状态（0=准备, 1=战斗, 2=结算）
        /// </summary>
        public int CurrentState;

        /// <summary>
        /// 存活玩家数量
        /// </summary>
        public int AlivePlayerCount;

        /// <summary>
        /// 已撤离玩家ID列表
        /// </summary>
        public List<long> EvacuatedPlayerIds;

        /// <summary>
        /// 已死亡玩家ID列表
        /// </summary>
        public List<long> DeadPlayerIds;

        /// <summary>
        /// 战局是否结束
        /// </summary>
        public bool IsFinished;
    }
}
```

#### 步骤3: System 设计

**BattleStateComponentSystem.cs** (Hotfix/Server)
```csharp
namespace ET.Server
{
    [EntitySystemOf(typeof(BattleStateComponent))]
    public static partial class BattleStateComponentSystem
    {
        [EntitySystem]
        private static void Awake(this BattleStateComponent self)
        {
            self.CurrentState = 0; // 准备状态
            self.EvacuatedPlayerIds = new List<long>();
            self.DeadPlayerIds = new List<long>();
            self.IsFinished = false;
        }

        [EntitySystem]
        private static void Update(this BattleStateComponent self)
        {
            // 检查战局结束条件
        }

        /// <summary>
        /// 切换到战斗状态
        /// </summary>
        public static void EnterBattle(this BattleStateComponent self)
        {
            // 实现逻辑
        }

        /// <summary>
        /// 处理玩家死亡
        /// </summary>
        public static void OnPlayerDead(this BattleStateComponent self, long playerId)
        {
            // 实现逻辑
        }

        /// <summary>
        /// 处理玩家撤离
        /// </summary>
        public static void OnPlayerEvacuate(this BattleStateComponent self, long playerId)
        {
            // 实现逻辑
        }

        /// <summary>
        /// 检查战局是否应该结束
        /// </summary>
        public static bool CheckBattleEnd(this BattleStateComponent self)
        {
            // 实现逻辑
            return false;
        }

        /// <summary>
        /// 切换到结算状态
        /// </summary>
        public static void EnterSettlement(this BattleStateComponent self)
        {
            // 实现逻辑
        }
    }
}
```

#### 步骤4: 测试用例设计

**Battle_StateFlow_Test.cs** (Hotfix/Test)
```csharp
namespace ET.Server
{
    /// <summary>
    /// 测试战局状态流转
    /// </summary>
    [Test]
    public class Battle_StateFlow_Test : ATestHandler
    {
        protected override async ETTask<int> Run(Fiber fiber, TestArgs args)
        {
            Scene scene = fiber.Root.CurrentScene();

            // 1. 创建战局会话
            BattleSessionComponent session = scene.AddComponent<BattleSessionComponent, long, int>(1001, 2);
            session.PlayerIds = new List<long> { 1001, 1002 };

            // 2. 创建战局状态
            BattleStateComponent state = session.AddComponent<BattleStateComponent>();
            state.AlivePlayerCount = 2;

            // 3. 验证初始状态
            if (state.CurrentState != 0)
            {
                Log.Console($"Initial state error, expected: 0, actual: {state.CurrentState}");
                return 1;
            }

            // 4. 进入战斗状态
            state.EnterBattle();

            if (state.CurrentState != 1)
            {
                Log.Console($"Battle state error, expected: 1, actual: {state.CurrentState}");
                return 2;
            }

            // 5. 模拟玩家死亡
            state.OnPlayerDead(1001);

            if (state.DeadPlayerIds.Count != 1)
            {
                Log.Console($"Dead player count error, expected: 1, actual: {state.DeadPlayerIds.Count}");
                return 3;
            }

            // 6. 检查战局结束
            bool shouldEnd = state.CheckBattleEnd();

            if (!shouldEnd)
            {
                Log.Console("Battle should end but didn't");
                return 4;
            }

            // 7. 进入结算状态
            state.EnterSettlement();

            if (state.CurrentState != 2)
            {
                Log.Console($"Settlement state error, expected: 2, actual: {state.CurrentState}");
                return 5;
            }

            Log.Debug("Battle state flow test passed");
            return ErrorCode.ERR_Success;
        }
    }
}
```

---

## 第3周：结算框架 + ECA 交互框架

### 目标
实现结算数据收集和 ECA（Event-Condition-Action）交互物基础框架

### Entity 设计

**SettlementComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 结算组件
    /// 收集和管理战局结算数据
    /// </summary>
    [ComponentOf(typeof(BattleSessionComponent))]
    public class SettlementComponent : Entity, IAwake, IDestroy
    {
        /// <summary>
        /// 玩家结算数据字典 PlayerId -> SettlementData
        /// </summary>
        public Dictionary<long, PlayerSettlementData> PlayerDataDict;

        /// <summary>
        /// 结算是否完成
        /// </summary>
        public bool IsCompleted;
    }

    /// <summary>
    /// 玩家结算数据
    /// </summary>
    public struct PlayerSettlementData
    {
        /// <summary>
        /// 玩家ID
        /// </summary>
        public long PlayerId;

        /// <summary>
        /// 是否存活
        /// </summary>
        public bool IsAlive;

        /// <summary>
        /// 击杀数
        /// </summary>
        public int KillCount;

        /// <summary>
        /// 获得经验
        /// </summary>
        public int ExpGained;

        /// <summary>
        /// 获得财富
        /// </summary>
        public int WealthGained;

        /// <summary>
        /// 带出的物品列表
        /// </summary>
        public List<int> ExtractedItems;
    }
}
```

**InteractableComponent.cs** (Model/Share)
```csharp
namespace ET
{
    /// <summary>
    /// 交互物组件
    /// ECA框架的基础组件
    /// </summary>
    [ComponentOf(typeof(Unit))]
    public class InteractableComponent : Entity, IAwake<int>, IDestroy
    {
        /// <summary>
        /// 交互物类型（1=容器, 2=撤离点, 3=NPC等）
        /// </summary>
        public int InteractType;

        /// <summary>
        /// 交互范围（米）
        /// </summary>
        public float InteractRange;

        /// <summary>
        /// 是否可交互
        /// </summary>
        public bool IsInteractable;

        /// <summary>
        /// 交互冷却时间（毫秒）
        /// </summary>
        public long CooldownTime;

        /// <summary>
        /// 上次交互时间
        /// </summary>
        public long LastInteractTime;
    }
}
```

### 测试用例设计

**Battle_Settlement_Test.cs**
```csharp
namespace ET.Server
{
    /// <summary>
    /// 测试结算流程
    /// </summary>
    [Test]
    public class Battle_Settlement_Test : ATestHandler
    {
        protected override async ETTask<int> Run(Fiber fiber, TestArgs args)
        {
            Scene scene = fiber.Root.CurrentScene();

            // 1. 创建战局和结算组件
            BattleSessionComponent session = scene.AddComponent<BattleSessionComponent, long, int>(1001, 2);
            SettlementComponent settlement = session.AddComponent<SettlementComponent>();

            // 2. 添加玩家结算数据
            settlement.AddPlayerData(1001, true, 5, 100, 500);
            settlement.AddPlayerData(1002, false, 2, 50, 0);

            // 3. 验证数据
            if (settlement.PlayerDataDict.Count != 2)
            {
                Log.Console($"Player data count error, expected: 2, actual: {settlement.PlayerDataDict.Count}");
                return 1;
            }

            // 4. 完成结算
            settlement.Complete();

            if (!settlement.IsCompleted)
            {
                Log.Console("Settlement not completed");
                return 2;
            }

            Log.Debug("Settlement test passed");
            return ErrorCode.ERR_Success;
        }
    }
}
```

---

## 第4周：多人 PVP 基础 + 集成测试

### 目标
实现多人同局支持，并进行端到端集成测试

### 关键功能

1. **多人同局支持**
   - 利用现有的 AOI 系统
   - 玩家状态同步
   - 战斗事件广播

2. **端到端测试**
   - 完整流程：匹配 → 进入战局 → 战斗 → 结算 → 返回大厅
   - 多人协同测试
   - 异常情况测试（断线、超时等）

### 集成测试用例

**Battle_E2E_PVP_Test.cs**
```csharp
namespace ET.Server
{
    /// <summary>
    /// 端到端PVP测试
    /// </summary>
    [Test]
    public class Battle_E2E_PVP_Test : ATestHandler
    {
        protected override async ETTask<int> Run(Fiber fiber, TestArgs args)
        {
            // 1. 创建两个玩家
            // 2. 发起匹配请求
            // 3. 验证匹配成功
            // 4. 进入战局
            // 5. 模拟战斗（一个玩家击杀另一个）
            // 6. 验证战局结束
            // 7. 验证结算数据
            // 8. 返回大厅

            Log.Debug("E2E PVP test passed");
            return ErrorCode.ERR_Success;
        }
    }
}
```

---

## 开发规范检查清单

### Entity 开发检查

- [ ] Entity 只包含数据字段，无方法
- [ ] 继承 Entity 基类
- [ ] 实现 IAwake 接口
- [ ] 添加 [ComponentOf] 或 [ChildOf] 特性
- [ ] Entity 只管理 Entity 和 struct，不管理非 Entity class
- [ ] 添加详细的中文注释

### System 开发检查

- [ ] System 类是静态类（static）
- [ ] 包含 partial 关键字
- [ ] 添加 [EntitySystemOf(typeof(对应Entity))] 特性
- [ ] 实现 Awake 生命周期方法
- [ ] 生命周期方法添加 [EntitySystem] 特性
- [ ] 生命周期方法声明为 private static
- [ ] 所有方法都是静态扩展方法
- [ ] 添加详细的中文注释

### EntityRef 和 await 检查

- [ ] Entity 字段使用 EntityRef<T> 而非直接引用
- [ ] await 前创建 EntityRef
- [ ] await 后通过 EntityRef 重新获取 Entity
- [ ] 不使用 EntityRef.Entity 属性（直接赋值）
- [ ] 检查 Entity 的 IsDisposed 状态

### 测试用例检查

- [ ] 测试类继承 ATestHandler
- [ ] 命名格式：{PackageType}_{TestName}_Test
- [ ] 文件放在 Scripts/Hotfix/Test/ 目录
- [ ] 使用 Log.Console 输出错误
- [ ] 每个错误返回唯一的数字错误码
- [ ] 成功返回 ErrorCode.ERR_Success
- [ ] 充分验证数据是否符合预期

### 包依赖检查

- [ ] packagegit.json 配置正确
- [ ] PackageType.cs 的 ID 与 packagegit.json 一致
- [ ] 依赖关系符合层级规范
- [ ] 递归添加所有依赖的依赖
- [ ] 不存在循环依赖

---

## 风险和注意事项

### 关键风险

1. **ECA 框架设计复杂度**
   - 缓解：先实现最小可用版本（仅支持基础交互）
   - 后续迭代：逐步添加条件判断、事件触发等高级功能

2. **多人同步问题**
   - 缓解：利用现有 AOI 和状态同步能力
   - 测试：重点测试边界情况（断线、延迟等）

3. **测试环境搭建**
   - 需要：完整的服务器环境
   - 依赖：现有的登录、地图、Unit 等系统

### 开发注意事项

1. **严格遵循 TDD 流程**
   - 先写 Test.md 设计文档
   - 再写测试用例
   - 最后实现代码

2. **每完成一个功能立即测试**
   - 编译：`dotnet build ET.sln -p:TreatWarningsAsErrors=false`
   - 测试：运行对应的测试用例
   - 回归：运行所有相关测试

3. **及时更新文档**
   - 完成功能后更新包的 AGENTS.md
   - 说明原理、实现和使用方法
   - 方便后续开发和 AI 理解

4. **代码质量**
   - 遵循命名规范
   - 添加详细注释
   - 避免 hard code
   - 注意性能优化

---

## 下一步行动

1. **确认开发计划**：仔细审阅本文档，确认是否需要调整
2. **准备开发环境**：确保编译通过，测试系统可用
3. **开始第1周开发**：从匹配系统的 Test.md 开始
4. **持续迭代**：按照 TDD 流程逐步完成所有功能
